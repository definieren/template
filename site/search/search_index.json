{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u3002","title":"Home"},{"location":"DataStructure/Bitset/","text":"\u57fa\u672c\u7528\u6cd5\u548c std::bitset \u4e00\u6837\uff0c\u533a\u522b\u662f\u4fee\u6539\u7528 .set() \uff0c\u67e5\u8be2\u7528 .get() \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 template < class T > struct BitSet { static_assert ( std :: is_unsigned_v < T > || std :: is_same_v < T , __uint128_t > , \"The type of bitset must be unsigned\" ); private : static constexpr size_t B = sizeof ( T ) * 8 , lg = std :: __lg ( B ); static_assert (( B & - B ) == B ); std :: vector < T > num ; static constexpr size_t ctz ( T x ) { if constexpr ( B <= 32 ) return __builtin_ctz ( x ); else if constexpr ( B == 64 ) return __builtin_ctzll ( x ); else { const unsigned long long lo = x & ( ~ 0ULL ), hi = x >> 64 ; if ( lo ) return __builtin_ctzll ( lo ); else return 64 + __builtin_ctzll ( hi ); } } static constexpr size_t ppc ( T x ) { if constexpr ( B <= 32 ) return __builtin_popcount ( x ); else if constexpr ( B == 64 ) return __builtin_popcountll ( x ); else return __builtin_popcountll ( x & ( ~ 0ULL )) + __builtin_popcountll ( x >> 64 ); } static constexpr size_t which_block ( size_t x ) { if constexpr ( B == 8 ) return x >> 3 ; else if constexpr ( B == 16 ) return x >> 4 ; else if constexpr ( B == 32 ) return x >> 5 ; else if constexpr ( B == 64 ) return x >> 6 ; else return x >> 7 ; } static constexpr size_t which_bit ( size_t x ) { if constexpr ( B == 8 ) return x & 7 ; else if constexpr ( B == 16 ) return x & 15 ; else if constexpr ( B == 32 ) return x & 31 ; else if constexpr ( B == 64 ) return x & 63 ; else return x & 127 ; } public : constexpr BitSet () : num {} {} explicit constexpr BitSet ( const std :: vector < T > & vec ) : num ( vec ) {} explicit constexpr BitSet ( const size_t & sz ) : num ( which_block ( sz + B - 1 )) {} explicit constexpr BitSet ( const std :: initializer_list < T > & a ) : num ( a ) {} template < class _InputIterator , class = std :: _RequireInputIter < _InputIterator >> explicit constexpr BitSet ( _InputIterator __first , _InputIterator __last ) : num ( __first , __last ) {} template < class F = bool ( * )( int ) > explicit constexpr BitSet ( const size_t & n , F f ) { resize ( n ); for ( size_t i = 0 ; i < n ; i ++ ) set ( i , f ( i )); } constexpr size_t size () const { return num . size () * B ; } constexpr void resize ( const size_t & sz ) { num . resize ( which_block ( sz + B - 1 )); return ; } constexpr BitSet & operator <<= ( const size_t & len ) { const size_t n = num . size (); if ( __builtin_expect ( len < size (), 1 )) { if ( __builtin_expect ( len != 0 , 1 )) { const size_t a = which_block ( len ), b = which_bit ( len ); if ( b == 0 ) { for ( size_t i = n - 1 ; i >= a ; i -- ) num [ i ] = num [ i - a ]; } else { const size_t _b = B - b ; for ( size_t i = n - 1 ; i > a ; i -- ) num [ i ] = ( num [ i - a ] << b ) | ( num [ i - a - 1 ] >> _b ); num [ a ] = num [ 0 ] << b ; } std :: fill ( num . begin (), num . begin () + a , static_cast < T > ( 0 )); } } else reset (); return * this ; } constexpr BitSet & operator >>= ( const size_t & len ) { const size_t n = num . size (); if ( __builtin_expect ( len < size (), 1 )) { if ( __builtin_expect ( len != 0 , 1 )) { const size_t a = which_block ( len ), b = which_bit ( len ), c = n - a - 1 ; if ( b == 0 ) { for ( size_t i = 0 ; i <= c ; i ++ ) num [ i ] = num [ i + a ]; } else { const size_t _b = B - b ; for ( size_t i = 0 ; i < c ; i ++ ) num [ i ] = ( num [ i + a ] >> b ) | ( num [ i + a + 1 ] << _b ); num [ c ] = num [ n - 1 ] >> b ; } std :: fill ( num . begin () + c + 1 , num . end (), static_cast < T > ( 0 )); } } else reset (); return * this ; } constexpr BitSet & operator |= ( const BitSet & rhs ) { const size_t n = size () / B , m = rhs . size () / B ; num . resize ( std :: max ( n , m )); for ( size_t i = 0 ; i < m ; i ++ ) num [ i ] |= rhs . num [ i ]; return * this ; } constexpr BitSet & operator &= ( const BitSet & rhs ) { const size_t n = size () / B , m = rhs . size () / B ; num . resize ( std :: max ( n , m )); for ( size_t i = 0 ; i < m ; i ++ ) num [ i ] &= rhs . num [ i ]; return * this ; } constexpr BitSet & operator ^= ( const BitSet & rhs ) { const size_t n = size () / B , m = rhs . size () / B ; num . resize ( std :: max ( n , m )); for ( size_t i = 0 ; i < m ; i ++ ) num [ i ] ^= rhs . num [ i ]; return * this ; } friend constexpr BitSet operator << ( BitSet lhs , const size_t & rhs ) { return lhs <<= rhs ; } friend constexpr BitSet operator >> ( BitSet lhs , const size_t & rhs ) { return lhs >>= rhs ; } friend constexpr BitSet operator | ( BitSet lhs , const BitSet & rhs ) { return lhs |= rhs ; } friend constexpr BitSet operator & ( BitSet lhs , const BitSet & rhs ) { return lhs &= rhs ; } friend constexpr BitSet operator ^ ( BitSet lhs , const BitSet & rhs ) { return lhs ^= rhs ; } friend constexpr BitSet operator ~ ( BitSet rhs ) { const size_t n = rhs . size () / B ; for ( size_t i = 0 ; i < n ; i ++ ) rhs . num [ i ] = ~ rhs . num [ i ]; return rhs ; } constexpr T operator [] ( const size_t & x ) const { assert ( x < num . size ()); return num [ x ]; } constexpr T & operator [] ( const size_t & x ) { assert ( x < num . size ()); return num [ x ]; } friend constexpr bool operator == ( const BitSet & lhs , const BitSet & rhs ) { const size_t n = lhs . size () / B , m = rhs . size () / B ; if ( n != m ) return false ; for ( size_t i = 0 ; i < n ; i ++ ) if ( lhs [ i ] != rhs [ i ]) return false ; return true ; } friend constexpr bool operator != ( const BitSet & lhs , const BitSet & rhs ) { return ! ( lhs == rhs ); } friend constexpr std :: ostream & operator << ( std :: ostream & os , const BitSet & x ) { const int n = x . size (); for ( int i = 0 ; i < n ; i ++ ) os << x . get ( i ); return os ; } constexpr unsigned get ( const size_t & x ) const { assert ( x < size ()); return ( num [ which_block ( x )] >> ( which_bit ( x ))) & 1 ; } constexpr void flip ( const size_t & x ) { assert ( x < size ()); num [ which_block ( x )] ^= ( static_cast < T > ( 1 ) << ( which_bit ( x ))); return ; } constexpr void set ( const size_t & x ) { assert ( x < size ()); num [ which_block ( x )] |= ( static_cast < T > ( 1 ) << which_bit ( x )); return ; } constexpr void set ( const size_t & x , const unsigned & o ) { assert ( x < size ()); o ? set ( x ) : reset ( x ); return ; } constexpr void set () { __builtin_memset ( num . data (), 0xff , sizeof ( T ) * num . size ()); return ; } constexpr void reset ( const size_t & x ) { assert ( x < size ()); num [ which_block ( x )] &= ~ ( static_cast < T > ( 1 ) << which_bit ( x )); return ; } constexpr void reset () { __builtin_memset ( num . data (), 0 , sizeof ( T ) * num . size ()); return ; } constexpr size_t count () const { size_t ret = 0 ; for ( auto i : num ) ret += ppc ( i ); return ret ; } constexpr bool none () const { for ( auto i : num ) if ( i != static_cast < T > ( 0 )) return false ; return true ; } constexpr bool all () const { for ( auto i : num ) if ( i != ( ~ static_cast < T > ( 0 ))) return false ; return true ; } constexpr bool any () const { return ! none (); } constexpr size_t Find_First () const { const size_t n = num . size (); for ( size_t i = 0 ; i < n ; i ++ ) if ( num [ i ] != static_cast < T > ( 0 )) return i * B + ctz ( num [ i ]); return size (); } constexpr size_t Find_Next ( size_t x ) const { const size_t n = num . size (); if ( ++ x >= size ()) return size (); size_t i = which_block ( x ), j = which_bit ( x ); T numi = num [ i ]; numi &= ( ~ static_cast < T > ( 0 )) << j ; if ( numi != static_cast < T > ( 0 )) return i * B + ctz ( numi ); for ( ++ i ; i < n ; i ++ ) { T numi = num [ i ]; if ( numi ) return i * B + ctz ( num [ i ]); } return size (); } }; using Bitset = BitSet < unsigned long long > ;","title":"Bitset"},{"location":"DataStructure/DisjointSet/","text":"\u5e76\u67e5\u96c6\uff0c\u4f7f\u7528\u8def\u5f84\u538b\u7f29\u52a0\u6309\u79e9\u5408\u5e76\uff0c\u5355\u6b21\u5747\u644a \\(O(\\alpha(n))\\) \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 struct DisjointSet { private : int n ; std :: vector < int > fa ; int _find ( int u ) { if ( fa [ u ] < 0 ) { return u ; } return fa [ u ] = _find ( fa [ u ]); } public : DisjointSet () : n {}, fa {} {} DisjointSet ( int n_ ) : n ( n_ ), fa ( n , -1 ) {} int find ( int u ) { assert ( 0 <= u && u < n ); return _find ( u ); } int merge ( int u , int v ) { assert ( 0 <= u && u < n ); assert ( 0 <= v && v < n ); u = _find ( u ), v = _find ( v ); if ( u == v ) { return u ; } if ( - fa [ u ] < - fa [ v ]) { std :: swap ( u , v ); } fa [ u ] += fa [ v ], fa [ v ] = u ; return u ; } int size ( int u ) { assert ( 0 <= u && u < n ); return - fa [ _find ( u )]; } bool same ( int u , int v ) { assert ( 0 <= u && u < n ); assert ( 0 <= v && v < n ); return _find ( u ) == _find ( v ); } std :: vector < std :: vector < int >> groups () { std :: vector < std :: vector < int >> ans ( n ); for ( int u = 0 ; u < n ; u ++ ) { if ( u == _find ( u )) { ans [ u ]. reserve ( - fa [ u ]); } } for ( int u = 0 ; u < n ; u ++ ) { ans [ _find ( u )]. push_back ( u ); } ans . erase ( std :: remove_if ( ans . begin (), ans . end (), [ & ]( const std :: vector < int >& v ) { return v . empty (); }), ans . end ()); return ans ; } };","title":"\u5e76\u67e5\u96c6"},{"location":"DataStructure/Fenwick/","text":"\u9700\u8981\u91cd\u8f7d\u8fd0\u7b97\u7b26 += \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 template < class T > struct Fenwick { private : int n , id ; vector < T > bit ; vector < int > vis ; inline constexpr int hole ( int k ) { return k + ( k >> 10 ); } constexpr void upd ( int x , T k ) { for ( x ++ ; x <= n ; x += x & - x ) { // for (x ++; x; x -= x & - x) { if ( vis [ hole ( x ) - 1 ] ^ id ) vis [ hole ( x ) - 1 ] = id , bit [ hole ( x ) - 1 ] = T {}; bit [ hole ( x ) - 1 ] += k ; } return ; } constexpr T qry ( int x ) { T ans {}; for ( x ++ ; x ; x -= x & - x ) // for (x ++; x <= n; x += x & - x) if ( vis [ hole ( x ) - 1 ] == id ) ans += bit [ hole ( x ) - 1 ]; return ans ; } public : constexpr Fenwick () : n ( 0 ), id ( 0 ), bit {}, vis {} {} constexpr Fenwick ( int _n ) : n ( _n ) { id = 0 ; vis . assign ( hole ( n ), 0 ); bit . assign ( hole ( n ), T {}); } constexpr void Clear () { ++ id ; return ; } // Single point addition, prefix / suffix summation. constexpr void Update ( int x , T k ) { return upd ( x , k ); } constexpr T Query ( int x ) { return qry ( x ); } // Single point addition, interval summation. // constexpr void Update(int x, T k) { return upd(x, k); } // constexpr T Query(int l, int r) { return qry(r) - qry(l - 1); } // Interval addition, single point summation. // constexpr void Update(int l, int r, T k) { upd(l, k), upd(r + 1, - k); return; } // constexpr T Query(int x) { return qry(x); } };","title":"\u6811\u72b6\u6570\u7ec4"},{"location":"DataStructure/HashMap/","text":"\u81ea\u5b9a\u4e49 Hash \u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct custom_hash { static uint64_t splitmix64 ( uint64_t x ) { // http://xorshift.di.unimi.it/splitmix64.c x += 0x9e3779b97f4a7c15 ; x = ( x ^ ( x >> 30 )) * 0xbf58476d1ce4e5b9 ; x = ( x ^ ( x >> 27 )) * 0x94d049bb133111eb ; return x ^ ( x >> 31 ); } size_t operator ()( uint64_t x ) const { static const uint64_t FIXED_RANDOM = chrono :: steady_clock :: now (). time_since_epoch (). count (); return splitmix64 ( x + FIXED_RANDOM ); } }; \u54c8\u5e0c\u8868 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 template < class Key , class T , class Hash = custom_hash > struct HashMap { private : u32 rest , msk ; std :: vector < Key > key ; std :: vector < T > val ; std :: vector < bool > used ; u64 H ( const Key & x ) { return Hash {}( x ) & msk ; } void rebuild () { std :: vector < std :: pair < Key , T >> d ; d . reserve ( used . size () / 2 - rest ); for ( u32 i = 0 ; i < used . size (); i ++ ) { if ( used [ i ]) { d . push_back ({ key [ i ], val [ i ]}); } } reserve ( 2 * d . size ()); for ( auto & [ x , y ] : d ) { ( * this )[ x ] = y ; } } u32 index ( const Key & k ) { u32 i = H ( k ); while ( used [ i ] && key [ i ] != k ) { ( ++ i ) &= msk ; } return i ; } public : HashMap () { reserve ( 0 ); } template < class _InputIterator , class = std :: _RequireInputIter < _InputIterator >> explicit HashMap ( _InputIterator __first , _InputIterator __last ) { reserve ( std :: distance ( __first , __last )); for ( auto it = __first ; it != __last ; it ++ ) { ( * this )[ it -> first ] = it -> second ; } } explicit HashMap ( const std :: vector < std :: pair < Key , T >> & a ) { reserve ( a . size ()); for ( auto i : a ) { ( * this )[ i . first ] = i . second ; } } void reserve ( u32 n ) { u32 n_ = 8 ; while ( n_ < n * 2 ) { n_ <<= 1 ; } rest = n_ / 2 , msk = n_ - 1 ; key . resize ( n_ ); val . resize ( n_ ); used . assign ( n_ , 0 ); } void clear () { used . assign ( used . size (), 0 ); rest = ( msk + 1 ) / 2 ; } auto size () const { return used . size () / 2 - rest ; } bool empty () const { return ! size (); } bool contains ( const Key & k ) const { u32 i = index ( k ); return used [ i ] && key [ i ] == k ; } T & operator [] ( const Key & k ) { if ( rest == 0 ) { rebuild (); } const u32 i = index ( k ); if ( ! used [ i ]) { used [ i ] = 1 ; key [ i ] = k ; val [ i ] = T {}; -- rest ; } return val [ i ]; } T operator [] ( const Key & k ) const { const u32 i = index ( k ); if ( ! used [ i ]) { return T {}; } return val [ i ]; } std :: vector < std :: pair < Key , T >> data () const { std :: vector < std :: pair < Key , T >> d ; d . reserve ( size ()); for ( u32 i = 0 ; i < used . size (); i ++ ) { if ( used [ i ]) { d . push_back ({ key [ i ], val [ i ]}); } } return d ; } template < class F = void ( * )( Key , T & ) > void enumerate_all ( const F & f ) { for ( u32 i = 0 ; i < used . size (); i ++ ) { if ( used [ i ]) { f ( key [ i ], val [ i ]); } } } };","title":"\u54c8\u5e0c\u8868"},{"location":"DataStructure/HashMap/#\u81ea\u5b9a\u4e49-hash-\u51fd\u6570","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct custom_hash { static uint64_t splitmix64 ( uint64_t x ) { // http://xorshift.di.unimi.it/splitmix64.c x += 0x9e3779b97f4a7c15 ; x = ( x ^ ( x >> 30 )) * 0xbf58476d1ce4e5b9 ; x = ( x ^ ( x >> 27 )) * 0x94d049bb133111eb ; return x ^ ( x >> 31 ); } size_t operator ()( uint64_t x ) const { static const uint64_t FIXED_RANDOM = chrono :: steady_clock :: now (). time_since_epoch (). count (); return splitmix64 ( x + FIXED_RANDOM ); } };","title":"\u81ea\u5b9a\u4e49 Hash \u51fd\u6570"},{"location":"DataStructure/HashMap/#\u54c8\u5e0c\u8868","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 template < class Key , class T , class Hash = custom_hash > struct HashMap { private : u32 rest , msk ; std :: vector < Key > key ; std :: vector < T > val ; std :: vector < bool > used ; u64 H ( const Key & x ) { return Hash {}( x ) & msk ; } void rebuild () { std :: vector < std :: pair < Key , T >> d ; d . reserve ( used . size () / 2 - rest ); for ( u32 i = 0 ; i < used . size (); i ++ ) { if ( used [ i ]) { d . push_back ({ key [ i ], val [ i ]}); } } reserve ( 2 * d . size ()); for ( auto & [ x , y ] : d ) { ( * this )[ x ] = y ; } } u32 index ( const Key & k ) { u32 i = H ( k ); while ( used [ i ] && key [ i ] != k ) { ( ++ i ) &= msk ; } return i ; } public : HashMap () { reserve ( 0 ); } template < class _InputIterator , class = std :: _RequireInputIter < _InputIterator >> explicit HashMap ( _InputIterator __first , _InputIterator __last ) { reserve ( std :: distance ( __first , __last )); for ( auto it = __first ; it != __last ; it ++ ) { ( * this )[ it -> first ] = it -> second ; } } explicit HashMap ( const std :: vector < std :: pair < Key , T >> & a ) { reserve ( a . size ()); for ( auto i : a ) { ( * this )[ i . first ] = i . second ; } } void reserve ( u32 n ) { u32 n_ = 8 ; while ( n_ < n * 2 ) { n_ <<= 1 ; } rest = n_ / 2 , msk = n_ - 1 ; key . resize ( n_ ); val . resize ( n_ ); used . assign ( n_ , 0 ); } void clear () { used . assign ( used . size (), 0 ); rest = ( msk + 1 ) / 2 ; } auto size () const { return used . size () / 2 - rest ; } bool empty () const { return ! size (); } bool contains ( const Key & k ) const { u32 i = index ( k ); return used [ i ] && key [ i ] == k ; } T & operator [] ( const Key & k ) { if ( rest == 0 ) { rebuild (); } const u32 i = index ( k ); if ( ! used [ i ]) { used [ i ] = 1 ; key [ i ] = k ; val [ i ] = T {}; -- rest ; } return val [ i ]; } T operator [] ( const Key & k ) const { const u32 i = index ( k ); if ( ! used [ i ]) { return T {}; } return val [ i ]; } std :: vector < std :: pair < Key , T >> data () const { std :: vector < std :: pair < Key , T >> d ; d . reserve ( size ()); for ( u32 i = 0 ; i < used . size (); i ++ ) { if ( used [ i ]) { d . push_back ({ key [ i ], val [ i ]}); } } return d ; } template < class F = void ( * )( Key , T & ) > void enumerate_all ( const F & f ) { for ( u32 i = 0 ; i < used . size (); i ++ ) { if ( used [ i ]) { f ( key [ i ], val [ i ]); } } } };","title":"\u54c8\u5e0c\u8868"},{"location":"DataStructure/Heap/","text":"\u53ef\u5220\u5806\u3002 Heap<T, cmp> \uff1a\u5143\u7d20\u7c7b\u578b\u4e3a T \uff0c\u6bd4\u8f83\u65b9\u5f0f\u4e3a cmp \u7684\u53ef\u5220\u5806\u3002 reduce() \uff1a\u5c06\u5806\u4e2d\u61d2\u60f0\u5220\u9664\u7684\u5143\u7d20\u6e05\u7a7a\u3002 push(x) \uff1a\u5411\u5806\u4e2d\u52a0\u5165\u5143\u7d20 \\(x\\) \u3002 pop(x) \uff1a\u5f39\u51fa\u5143\u7d20\uff08\u82e5\u65e0\u4f20\u53c2\u5219\u4e3a\u5f39\u51fa\u5806\u9876\uff09\u3002 top() \uff1a\u8fd4\u56de\u5806\u9876\u5143\u7d20\u3002 size() \uff1a\u8fd4\u56de\u5806\u4e2d\u5143\u7d20\u4e2a\u6570\u3002 empty() \uff1a\u8fd4\u56de\u5806\u662f\u5426\u4e3a\u7a7a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 template < class T , class cmp = std :: less < T >> struct Heap { private : std :: priority_queue < T , std :: vector < T > , cmp > addQ , delQ ; public : Heap () : addQ {}, delQ {} {} void reduce () { assert ( addQ . size () >= delQ . size ()); while ( delQ . size () && addQ . top () == delQ . top ()) { addQ . pop (), delQ . pop (); } } void push ( T x ) { addQ . push ( x ); } void pop ( T x ) { delQ . push ( x ); } void pop () { reduce (); assert ( addQ . size ()); addQ . pop (); } T top () { reduce (); assert ( addQ . size ()); return addQ . top (); } size_t size () { assert ( addQ . size () >= delQ . size ()); return addQ . size () - delQ . size (); } bool empty () { return ! size (); } };","title":"\u53ef\u5220\u5806"},{"location":"DataStructure/RMQ/","text":"\\(O(n) - O(1)\\) RMQ\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 template < class T , class Cmp = less < T >> struct RMQ { static constexpr unsigned B = 64 ; const Cmp cmp = Cmp (); unsigned n ; vector < vector < T >> st ; vector < T > pre , suf , A ; vector < unsigned long long > stk ; RMQ () {} RMQ ( const vector < T > & a ) { Init ( a ); } inline void chkmin ( T & a , T b ) { if ( cmp ( b , a )) { a = b ; } return ; } void Init ( const vector < T > & a ) { n = a . size (); pre = suf = A = a ; stk . resize ( n ); if ( ! n ) { return ; } const int Bn = ( n - 1 ) / B + 1 ; const int LG = __lg ( Bn ); st . assign ( LG + 1 , vector < T > ( Bn )); for ( int i = 0 ; i < Bn ; i ++ ) { st [ 0 ][ i ] = a [ i * B ]; for ( unsigned j = 1 ; j < B && i * B + j < n ; j ++ ) { chkmin ( st [ 0 ][ i ], a [ i * B + j ]); } } for ( unsigned i = 1 ; i < n ; i ++ ) { if ( i % B ) { chkmin ( pre [ i ], pre [ i - 1 ]); } } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i % B != B - 1 ) { chkmin ( suf [ i ], suf [ i + 1 ]); } } for ( int i = 0 ; i < LG ; i ++ ) { for ( int j = 0 ; j + ( 2 << i ) <= Bn ; j ++ ) { st [ i + 1 ][ j ] = min ( st [ i ][ j ], st [ i ][ j + ( 1 << i )], cmp ); } } for ( int i = 0 ; i < Bn ; i ++ ) { const int l = i * B ; const int r = min ( n , l + B ); unsigned long long msk = 0 ; for ( int j = l ; j < r ; j ++ ) { while ( msk && cmp ( a [ j ], a [ __lg ( msk ) + l ])) { msk ^= 1ULL << __lg ( msk ); } msk |= 1ULL << ( j - l ); stk [ j ] = msk ; } } return ; } inline int Query ( int l , int r ) { if ( l / B != ( r - 1 ) / B ) { T ans = min ( suf [ l ], pre [ r - 1 ], cmp ); l = l / B + 1 , r = r / B ; if ( l < r ) { int k = __lg ( r - l ); chkmin ( ans , min ( st [ k ][ l ], st [ k ][ r - ( 1 << k )], cmp )); } return ans ; } else { int x = B * ( l / B ); return A [ __builtin_ctzll ( stk [ r - 1 ] >> ( l - x )) + l ]; } } };","title":"RMQ"},{"location":"DataStructure/SegmentTree/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 template < class Info , class Tag > struct Segment_Tree { private : int n ; vector < int > ps ; struct Node { Info dt ; Tag tg ; }; vector < Node > sgt ; vector < Info > ve ; vector < int > _vec ; vector < tuple < int , int , int >> vec ; constexpr void Push_Up ( int p ) { sgt [ p ]. dt = sgt [ p << 1 ]. dt + sgt [ p << 1 | 1 ]. dt ; return ; } constexpr void Push_Tag ( int p , Tag tg ) { sgt [ p ]. dt = tg . Apply ( sgt [ p ]. dt ), sgt [ p ]. tg = tg * sgt [ p ]. tg ; return ; } constexpr void Push_Down ( int p ) { if ( sgt [ p ]. tg ) Push_Tag ( p << 1 , sgt [ p ]. tg ), Push_Tag ( p << 1 | 1 , sgt [ p ]. tg ), sgt [ p ]. tg = Tag (); return ; } constexpr void Build ( int p , int L , int R ) { sgt [ p ]. tg = Tag (); if ( L == R ) { ps [ L ] = p ; sgt [ p ]. dt = ve [ L ]; return ; } int Mid = ( L + R ) >> 1 ; Build ( p << 1 , L , Mid ); Build ( p << 1 | 1 , Mid + 1 , R ); Push_Up ( p ); return ; } constexpr void Extract ( int l , int r , int p , int L , int R ) { if ( l <= L && R <= r ) { vec . emplace_back ( p , L , R ); return ; } Push_Down ( p ); int Mid = ( L + R ) >> 1 ; if ( l <= Mid ) Extract ( l , r , p << 1 , L , Mid ); if ( Mid < r ) Extract ( l , r , p << 1 | 1 , Mid + 1 , R ); _vec . emplace_back ( p ); return ; } public : constexpr Segment_Tree ( int _n ) { Build ( _n ); } template < class T > constexpr Segment_Tree ( const vector < T > & a ) { Build ( a ); } template < class _InputIterator , class = _RequireInputIter < _InputIterator >> constexpr Segment_Tree ( _InputIterator __first , _InputIterator __last ) { Build ( __first , __last ); } template < class F > constexpr Segment_Tree ( int _n , F f ) { Build < F > ( _n , f ); } constexpr void Build ( int _n ) { ve . assign ( n = _n , Info {}); sgt . assign ( n << 2 , Node {}); ps . assign ( n , 0 ); Build ( 1 , 0 , n - 1 ); return ; } template < class T > constexpr void Build ( const vector < T > & a ) { ve . resize ( n = ( int ) a . size ()); sgt . assign ( n << 2 , Node {}); ps . assign ( n , 0 ); for ( int i = 0 ; i < n ; i ++ ) ve [ i ] = a [ i ]; Build ( 1 , 0 , n - 1 ); return ; } template < class _InputIterator , class = _RequireInputIter < _InputIterator >> constexpr void Build ( _InputIterator __first , _InputIterator __last ) { ve . resize ( n = __last - __first ); sgt . assign ( n << 2 , Node {}); ps . assign ( n , 0 ); for ( auto it = __first ; it != __last ; it ++ ) ve [ it - __first ] = * it ; Build ( 1 , 0 , n - 1 ); return ; } template < class F > constexpr void Build ( int _n , F f ) { ve . resize ( n = _n ); sgt . assign ( n << 2 , Node {}); ps . assign ( n , 0 ); for ( int i = 0 ; i < n ; i ++ ) ve [ i ] = f ( i ); Build ( 1 , 0 , n - 1 ); return ; } constexpr void Update ( int l , int r , Tag k ) { _vec . clear (), vec . clear (); Extract ( l , r , 1 , 0 , n - 1 ); for ( auto [ p , L , R ] : vec ) Push_Tag ( p , k ); for ( auto p : _vec ) Push_Up ( p ); return ; } constexpr void Update ( int pos , Tag k ) { _vec . clear (); pos = ps [ pos ]; while ( pos ) _vec . emplace_back ( pos ), pos >>= 1 ; for ( int i = ( int ) _vec . size () - 1 ; i ; i -- ) Push_Down ( _vec [ i ]); Push_Tag ( _vec . front (), k ); for ( int i = 1 ; i < ( int ) _vec . size (); i ++ ) Push_Up ( _vec [ i ]); return ; } constexpr void Change ( int pos , Info k ) { _vec . clear (); pos = ps [ pos ]; while ( pos ) _vec . emplace_back ( pos ), pos >>= 1 ; for ( int i = ( int ) _vec . size () - 1 ; i ; i -- ) Push_Down ( _vec [ i ]); sgt [ _vec . front ()]. dt = k ; for ( int i = 1 ; i < ( int ) _vec . size (); i ++ ) Push_Up ( _vec [ i ]); return ; } constexpr Info Query () { return sgt [ 1 ]. dt ; } constexpr Info Query ( int l , int r ) { _vec . clear (), vec . clear (); Extract ( l , r , 1 , 0 , n - 1 ); Info ans = sgt [ get < 0 > ( vec . front ())]. dt ; for ( int i = 1 ; i < ( int ) vec . size (); i ++ ) ans = ans + sgt [ get < 0 > ( vec [ i ])]. dt ; return ans ; } constexpr Info Query ( int pos ) { _vec . clear (); pos = ps [ pos ]; while ( pos ) _vec . emplace_back ( pos ), pos >>= 1 ; for ( int i = ( int ) _vec . size () - 1 ; i ; i -- ) Push_Down ( _vec [ i ]); return sgt [ _vec . front ()]. dt ; } template < class Compare > constexpr pair < int , Info > Find_Nxt ( int l , int r , Info k , Compare comp ) { _vec . clear (), vec . clear (); Extract ( l , r , 1 , 0 , n - 1 ); for ( auto [ p , L , R ] : vec ) { if ( ! comp ( k , sgt [ p ]. dt )) continue ; while ( L < R ) { int Mid = ( L + R ) >> 1 ; Push_Down ( p ); if ( comp ( k , sgt [ p << 1 ]. dt )) R = Mid , p <<= 1 ; else L = Mid + 1 , p = p << 1 | 1 ; } return { L , sgt [ p ]. dt }; } return { r + 1 , Info ()}; } template < class Compare > constexpr pair < int , Info > Find_Pre ( int l , int r , Info k , Compare comp ) { _vec . clear (), vec . clear (); Extract ( l , r , 1 , 0 , n - 1 ); reverse ( vec . begin (), vec . end ()); for ( auto [ p , L , R ] : vec ) { if ( ! comp ( k , sgt [ p ]. dt )) continue ; while ( L < R ) { int Mid = ( L + R ) >> 1 ; Push_Down ( p ); if ( ! comp ( k , sgt [ p << 1 | 1 ]. dt )) R = Mid , p <<= 1 ; else L = Mid + 1 , p = p << 1 | 1 ; } return { L , sgt [ p ]. dt }; } return { l - 1 , Info ()}; } }; struct Info { Info () {} friend Info operator + ( Info x , Info y ) { } }; struct Tag { Tag () {} operator bool () { } friend Tag operator * ( Tag x , Tag y ) { } Info Apply ( Info x ) { } };","title":"\u7ebf\u6bb5\u6811"},{"location":"DefaultSource/DefaultSource/","text":"\u7b80\u7565\u7248\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <bits/stdc++.h> using u32 = unsigned ; using i64 = long long ; using u64 = unsigned long long ; using i128 = __int128 ; using u128 = unsigned __int128 ; int main () { #ifdef LOCAL freopen ( \"!in.in\" , \"r\" , stdin ); freopen ( \"!out.out\" , \"w\" , stdout ); #endif std :: ios :: sync_with_stdio ( false ); std :: cin . tie ( nullptr ); std :: cout . tie ( nullptr ); return 0 ; } \u957f\u7248\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 #include <bits/stdc++.h> #define fir first #define sec second #define mkp make_pair #define mkt make_tuple #ifdef LOCAL #define dbg(x) cerr << \"In Line \" << __LINE__ << \" the \" << #x << \" = \" << x << '\\n' #define dpi(x, y) cerr << \"In Line \" << __LINE__ << \" the \" << #x << \" = \" << x << \" ; \" << \"the \" << #y << \" = \" << y << '\\n' #define dbgf(fmt, args...) fprintf(stderr, fmt, ##args) #else #define dbg(x) void() #define dpi(x, y) void() #define dbgf(fmt, args...) void() #endif using namespace std ; using i64 = long long ; using u64 = unsigned long long ; using u32 = unsigned int ; using ldb = long double ; using i128 = __int128_t ; using u128 = __uint128_t ; using pii = pair < int , int > ; using pil = pair < int , i64 > ; using pli = pair < i64 , int > ; using vi = vector < int > ; using vpii = vector < pii > ; namespace { bool Mbe ; constexpr int MOD = 998244353 ; template < typename T > T Norm ( T a , T p = MOD ) { return ( a % p + p ) % p ; } template < typename T > bool cmax ( T & a , T b ) { return a < b ? a = b , true : false ; } template < typename T > bool cmin ( T & a , T b ) { return a > b ? a = b , true : false ; } template < typename T > T DivFloor ( T a , T b ) { return a >= 0 ? a / b : ( a - b + 1 ) / b ; } template < typename T > T DivCeil ( T a , T b ) { return a >= 0 ? ( a + b - 1 ) / b : a / b ; } namespace FastIO { constexpr int LEN = 1 << 20 ; char in [ LEN + 1 ], out [ LEN + 1 ]; char * pin = in , * pout = out , * ein = in , * eout = out + LEN ; char gc () { return pin == ein && ( ein = ( pin = in ) + fread ( in , 1 , LEN , stdin ), ein == in ) ? EOF : * pin ++ ; } void pc ( char c ) { pout == eout && ( fwrite ( out , 1 , LEN , stdout ), pout = out ); ( * pout ++ ) = c ; return ; } struct Flush { ~ Flush () { fwrite ( out , 1 , pout - out , stdout ); pout = out ; return ; } } _flush ; template < typename T > T Read () { T x = 0 ; int f = 1 ; char ch = gc (); while ( ch < '0' || ch > '9' ) f = ( ch == '-' ? ( ~ f + 1 ) : f ), ch = gc (); while ( ch >= '0' && ch <= '9' ) x = ( x << 1 ) + ( x << 3 ) + ( ch ^ 48 ), ch = gc (); return x * f ; } void Read ( char * s ) { char ch = gc (); while ( ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t' ) ch = gc (); while (( ch != EOF ) && ! ( ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t' )) * s = ch , s ++ , ch = gc (); * s = '\\0' ; return ; } template < typename T > void Read ( T & x ) { x = Read < T > (); return ; } template < typename T , typename ... Args > void Read ( T & x , Args & ... args ) { Read ( x ), Read ( args ...); return ; } template < typename T > void Write ( T x ) { static char stk [ 40 ]; int tp = 0 ; if ( x < 0 ) pc ( '-' ), x = ~ x + 1 ; do stk [ tp ++ ] = x % 10 + 48 , x /= 10 ; while ( x ); while ( tp -- ) pc ( stk [ tp ]); return ; } void Write ( char ch ) { pc ( ch ); return ; } void Write ( const char * s ) { while ( * s != '\\0' ) pc ( * s ), s ++ ; return ; } void Puts ( const char * s ) { Write ( s ), pc ( '\\n' ); return ; } template < typename T , typename ... Args > void Write ( T x , Args ... args ) { Write ( x ), Write ( args ...); return ; } } using namespace FastIO ; void slv () { return ; } void clr () { return ; } bool Med ; } int main () { #ifdef LOCAL freopen ( \"!in.in\" , \"r\" , stdin ); freopen ( \"!out.out\" , \"w\" , stdout ); fprintf ( stderr , \"%.3lf Mb \\n \" , fabs (( & Mbe - & Med ) / 1048576.0 )); #endif int T = 1 ; // int T = Read<int>(); while ( T -- ) slv (), clr (); #ifdef LOCAL fprintf ( stderr , \"%d ms \\n \" , ( int ) clock ()); #endif return 0 ; }","title":"\u7f3a\u7701\u6e90"},{"location":"Graph/BlockCutTree/","text":"\u5706\u65b9\u6811 \u9700\u524d\u7f6e GraphBase.md \u3002 block_cut(G) \uff1a\u8fd4\u56de\u56fe \\(G\\) \u7684\u5706\u65b9\u6811\uff0c\u65b9\u70b9\u7f16\u53f7\u4e3a \\([n, n + \\# \\text{block})\\) \uff0c\u5706\u70b9\u7f16\u53f7\u4e3a \\([0, n)\\) \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 template < class Graph > graph <> block_cut ( const Graph & G ) { assert ( ! G . is_directed ); assert ( G . is_prepared ()); const int n = G . n ; std :: vector < int > low ( n ), dfn ( n , -1 ), stk ; graph <> bct ( 2 * n ); stk . reserve ( n ); int cur = n , dfc = 0 ; auto dfs = [ & ]( auto && self , int u ) -> void { low [ u ] = dfn [ u ] = dfc ++ ; stk . push_back ( u ); for ( auto e : G [ u ]) { const int v = e . v ; if ( dfn [ v ] == -1 ) { self ( self , v ); low [ u ] = std :: min ( low [ u ], low [ v ]); if ( low [ v ] == dfn [ u ]) { for ( int x = -1 ; x != v ; stk . pop_back ()) { x = stk . back (); bct . addEdge ( cur , x ); } bct . addEdge ( cur , u ); cur ++ ; } } else { low [ u ] = std :: min ( low [ u ], dfn [ v ]); } } }; for ( int u = 0 ; u < n ; u ++ ) { stk . clear (); if ( dfn [ u ] == -1 ) { dfs ( dfs , u ); if ( dfn [ u ] + 1 == dfc ) { bct . addEdge ( cur , u ); cur ++ ; } } } bct . n = cur , bct . build (); return bct ; }","title":"\u5706\u65b9\u6811"},{"location":"Graph/BlockCutTree/#\u5706\u65b9\u6811","text":"\u9700\u524d\u7f6e GraphBase.md \u3002 block_cut(G) \uff1a\u8fd4\u56de\u56fe \\(G\\) \u7684\u5706\u65b9\u6811\uff0c\u65b9\u70b9\u7f16\u53f7\u4e3a \\([n, n + \\# \\text{block})\\) \uff0c\u5706\u70b9\u7f16\u53f7\u4e3a \\([0, n)\\) \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 template < class Graph > graph <> block_cut ( const Graph & G ) { assert ( ! G . is_directed ); assert ( G . is_prepared ()); const int n = G . n ; std :: vector < int > low ( n ), dfn ( n , -1 ), stk ; graph <> bct ( 2 * n ); stk . reserve ( n ); int cur = n , dfc = 0 ; auto dfs = [ & ]( auto && self , int u ) -> void { low [ u ] = dfn [ u ] = dfc ++ ; stk . push_back ( u ); for ( auto e : G [ u ]) { const int v = e . v ; if ( dfn [ v ] == -1 ) { self ( self , v ); low [ u ] = std :: min ( low [ u ], low [ v ]); if ( low [ v ] == dfn [ u ]) { for ( int x = -1 ; x != v ; stk . pop_back ()) { x = stk . back (); bct . addEdge ( cur , x ); } bct . addEdge ( cur , u ); cur ++ ; } } else { low [ u ] = std :: min ( low [ u ], dfn [ v ]); } } }; for ( int u = 0 ; u < n ; u ++ ) { stk . clear (); if ( dfn [ u ] == -1 ) { dfs ( dfs , u ); if ( dfn [ u ] + 1 == dfc ) { bct . addEdge ( cur , u ); cur ++ ; } } } bct . n = cur , bct . build (); return bct ; }","title":"\u5706\u65b9\u6811"},{"location":"Graph/Flow/","text":"\u6700\u5927\u6d41 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 template < class Cap > struct MaxFlow_Graph { private : struct _Edge { int to , rev ; Cap cap ; }; int n ; vector < pair < int , int >> pos ; vector < vector < _Edge >> G ; public : struct Edge { int u , v ; Cap cap , flow ; }; MaxFlow_Graph () : n ( 0 ) { G . clear (), pos . clear (); return ; } explicit MaxFlow_Graph ( int _n ) : n ( _n ) { G . assign ( n , vector < _Edge > ()), pos . clear (); return ; } int Add_Edge ( int u , int v , Cap cap ) { int m = ( int ) pos . size (); pos . emplace_back ( u , ( int ) G [ u ]. size ()); int uid = ( int ) G [ u ]. size (), vid = ( int ) G [ v ]. size (); if ( u == v ) vid ++ ; G [ u ]. emplace_back ( v , vid , cap ); G [ v ]. emplace_back ( u , uid , 0 ); return m ; } Edge Get_Edge ( int i ) { auto e = G [ pos [ i ]. fir ][ pos [ i ]. sec ], re = G [ e . to ][ e . rev ]; return Edge { pos [ i ]. fir , e . to , e . cap + re . cap , re . cap }; } vector < Edge > Get_All_Edges () { int m = ( int ) pos . size (); vector < Edge > res ; for ( int i = 0 ; i < m ; i ++ ) res . emplace_back ( Get_Edge ( i )); return res ; } void Change_Edge ( int i , Cap _cap , Cap _flow ) { auto & e = G [ pos [ i ]. fir ][ pos [ i ]. sec ], & re = G [ e . to ][ e . rev ]; e . cap = _cap - _flow , re . cap = _flow ; return ; } Cap Max_Flow ( int S , int T ) { return Max_Flow ( S , T , numeric_limits < Cap >:: max ()); } Cap Max_Flow ( int S , int T , Cap lim ) { Cap flow = 0 ; vector < int > dep ( n ), cur ( n ); queue < int > Q ; auto BFS = [ & ]() { fill ( dep . begin (), dep . end (), -1 ); while ( Q . size ()) Q . pop (); Q . emplace ( S ), dep [ S ] = 0 ; while ( Q . size ()) { int u = Q . front (); Q . pop (); for ( auto e : G [ u ]) { if ( e . cap == 0 || ~ dep [ e . to ]) continue ; dep [ e . to ] = dep [ u ] + 1 ; if ( e . to == T ) return true ; Q . emplace ( e . to ); } } return false ; }; auto DFS = [ & ]( auto self , int u , Cap flow ) { if ( u == T ) return flow ; Cap used = 0 ; for ( int & i = cur [ u ]; i < ( int ) G [ u ]. size (); i ++ ) { auto & e = G [ u ][ i ], & re = G [ e . to ][ e . rev ]; if ( dep [ e . to ] == dep [ u ] + 1 && e . cap ) { Cap d = self ( self , e . to , min ( flow - used , e . cap )); if ( d > 0 ) e . cap -= d , re . cap += d , used += d ; else dep [ e . to ] = -1 ; if ( flow == used ) break ; } } return used ; }; while ( flow < lim && BFS ()) { for ( int i = 0 ; i < n ; i ++ ) cur [ i ] = 0 ; Cap f = DFS ( DFS , S , lim - flow ); if ( ! f ) break ; flow += f ; } return flow ; } vector < bool > Min_Cut ( int S ) { vector < bool > vis ( n ); queue < int > Q ; Q . emplace ( S ), vis [ S ] = true ; while ( Q . size ()) { int u = Q . front (); Q . pop (); for ( auto e : G [ u ]) if ( e . cap && ! vis [ e . to ]) vis [ e . to ] = true , Q . emplace ( e . to ); } return vis ; } }; \u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 template < class Cap , class Cost > struct MCMF_Graph { public : struct Edge { int u , v ; Cap cap , flow ; Cost cost ; }; constexpr MCMF_Graph () : n ( 0 ) {} explicit constexpr MCMF_Graph ( int _n ) : n ( _n ) {} constexpr int Add_Edge ( int u , int v , Cap cap , Cost cost ) { assert ( 0 <= u && u < n ); assert ( 0 <= v && v < n ); assert ( 0 <= cap ); assert ( 0 <= cost ); const int m = static_cast < int > ( edge . size ()); edge . emplace_back ( u , v , cap , 0 , cost ); return m ; } constexpr Edge Get_Edge ( int i ) { const int m = static_cast < int > ( edge . size ()); assert ( 0 <= i && i < m ); return edge [ i ]; } constexpr vector < Edge > Get_All_Edges () { return edge ; } constexpr pair < Cap , Cost > MCMF ( int S , int T ) { return MCMF ( S , T , numeric_limits < Cap >:: max ()); } constexpr pair < Cap , Cost > MCMF ( int S , int T , Cap lim ) { return Slope ( S , T , lim ). back (); } constexpr vector < pair < Cap , Cost >> Slope ( int S , int T ) { return Slope ( S , T , numeric_limits < Cap >:: max ()); } constexpr vector < pair < Cap , Cost >> Slope ( int S , int T , Cap lim ) { assert ( 0 <= S && S < n ); assert ( 0 <= T && T < n ); assert ( S != T ); const int m = static_cast < int > ( edge . size ()); vector < int > idx ( m ), rev ( m ), deg ( n ); vector < pair < int , _Edge >> elist ( 2 * m ); for ( int i = 0 ; i < m ; i ++ ) { auto e = edge [ i ]; idx [ i ] = deg [ e . u ] ++ ; rev [ i ] = deg [ e . v ] ++ ; elist [ i * 2 ] = { e . u , { e . v , -1 , e . cap - e . flow , e . cost }}; elist [ i * 2 + 1 ] = { e . v , { e . u , -1 , e . flow , - e . cost }}; } auto G = Graph ( n , elist ); for ( int i = 0 ; i < m ; i ++ ) { auto e = edge [ i ]; idx [ i ] += G . head [ e . u ]; rev [ i ] += G . head [ e . v ]; G . elist [ idx [ i ]]. rev = rev [ i ]; G . elist [ rev [ i ]]. rev = idx [ i ]; } auto ans = Slope ( G , S , T , lim ); for ( int i = 0 ; i < m ; i ++ ) { auto e = G . elist [ idx [ i ]]; edge [ i ]. flow = edge [ i ]. cap - e . cap ; } return ans ; } private : int n ; vector < Edge > edge ; struct _Edge { int to , rev ; Cap cap ; Cost cost ; }; struct Graph { vector < int > head ; vector < _Edge > elist ; explicit constexpr Graph ( int n , const vector < pair < int , _Edge >>& edges ) : head ( n + 1 ), elist ( edges . size ()) { for ( auto e : edges ) { ++ head [ e . first + 1 ]; } for ( int i = 1 ; i <= n ; i ++ ) { head [ i ] += head [ i - 1 ]; } auto cnt = head ; for ( auto e : edges ) { elist [ cnt [ e . first ] ++ ] = e . second ; } } }; constexpr vector < pair < Cap , Cost >> Slope ( Graph & G , int S , int T , Cap lim ) { struct Element { Cost cost ; int to ; constexpr bool operator < ( const Element & rhs ) const { return cost > rhs . cost ; } }; const Cost inf = numeric_limits < Cost >:: max (); vector < Cost > dual ( n ), dist ( n ); vector < int > pre ( n ), Qmn ; vector < bool > vis ( n ); vector < Element > Q ; auto Dijkstra = [ & ]() { fill ( dist . begin (), dist . end (), inf ); fill ( vis . begin (), vis . end (), false ); Qmn . clear (), Q . clear (); size_t tl = 0 ; dist [ S ] = 0 ; Qmn . emplace_back ( S ); while ( Qmn . size () || Q . size ()) { int u ; if ( Qmn . size ()) { u = Qmn . back (); Qmn . pop_back (); } else { while ( tl < Q . size ()) { push_heap ( Q . begin (), Q . begin () + ( ++ tl )); } u = Q . front (). to ; pop_heap ( Q . begin (), Q . end ()); Q . pop_back (), -- tl ; } if ( vis [ u ]) { continue ; } vis [ u ] = true ; if ( u == T ) { break ; } Cost dual_u = dual [ u ], dist_u = dist [ u ]; for ( int i = G . head [ u ]; i < G . head [ u + 1 ]; i ++ ) { auto e = G . elist [ i ]; if ( ! e . cap ) { continue ; } Cost cost = e . cost - dual [ e . to ] + dual_u ; if ( dist_u + cost < dist [ e . to ]) { Cost dist_v = dist_u + cost ; dist [ e . to ] = dist_v , pre [ e . to ] = e . rev ; if ( dist_v == dist_u ) { Qmn . emplace_back ( e . to ); } else { Q . emplace_back ( dist_v , e . to ); } } } } if ( ! vis [ T ]) { return false ; } for ( int u = 0 ; u < n ; u ++ ) { if ( ! vis [ u ]) { continue ; } dual [ u ] -= dist [ T ] - dist [ u ]; } return true ; }; Cap flow = 0 ; Cost cost = 0 , pre_slope = -1 ; vector < pair < Cap , Cost >> slope = {{ Cap ( 0 ), Cost ( 0 )}}; while ( flow < lim && Dijkstra ()) { Cap c = lim - flow ; Cost d = - dual [ S ]; for ( int u = T ; u != S ; u = G . elist [ pre [ u ]]. to ) { c = min ( c , G . elist [ G . elist [ pre [ u ]]. rev ]. cap ); } for ( int u = T ; u != S ; u = G . elist [ pre [ u ]]. to ) { auto & e = G . elist [ pre [ u ]]; e . cap += c , G . elist [ e . rev ]. cap -= c ; } flow += c , cost += c * d ; if ( pre_slope == d ) { slope . back () = { flow , cost }; } else { slope . emplace_back ( flow , cost ); } pre_slope = d ; } return slope ; } };","title":"\u7f51\u7edc\u6d41"},{"location":"Graph/Flow/#\u6700\u5927\u6d41","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 template < class Cap > struct MaxFlow_Graph { private : struct _Edge { int to , rev ; Cap cap ; }; int n ; vector < pair < int , int >> pos ; vector < vector < _Edge >> G ; public : struct Edge { int u , v ; Cap cap , flow ; }; MaxFlow_Graph () : n ( 0 ) { G . clear (), pos . clear (); return ; } explicit MaxFlow_Graph ( int _n ) : n ( _n ) { G . assign ( n , vector < _Edge > ()), pos . clear (); return ; } int Add_Edge ( int u , int v , Cap cap ) { int m = ( int ) pos . size (); pos . emplace_back ( u , ( int ) G [ u ]. size ()); int uid = ( int ) G [ u ]. size (), vid = ( int ) G [ v ]. size (); if ( u == v ) vid ++ ; G [ u ]. emplace_back ( v , vid , cap ); G [ v ]. emplace_back ( u , uid , 0 ); return m ; } Edge Get_Edge ( int i ) { auto e = G [ pos [ i ]. fir ][ pos [ i ]. sec ], re = G [ e . to ][ e . rev ]; return Edge { pos [ i ]. fir , e . to , e . cap + re . cap , re . cap }; } vector < Edge > Get_All_Edges () { int m = ( int ) pos . size (); vector < Edge > res ; for ( int i = 0 ; i < m ; i ++ ) res . emplace_back ( Get_Edge ( i )); return res ; } void Change_Edge ( int i , Cap _cap , Cap _flow ) { auto & e = G [ pos [ i ]. fir ][ pos [ i ]. sec ], & re = G [ e . to ][ e . rev ]; e . cap = _cap - _flow , re . cap = _flow ; return ; } Cap Max_Flow ( int S , int T ) { return Max_Flow ( S , T , numeric_limits < Cap >:: max ()); } Cap Max_Flow ( int S , int T , Cap lim ) { Cap flow = 0 ; vector < int > dep ( n ), cur ( n ); queue < int > Q ; auto BFS = [ & ]() { fill ( dep . begin (), dep . end (), -1 ); while ( Q . size ()) Q . pop (); Q . emplace ( S ), dep [ S ] = 0 ; while ( Q . size ()) { int u = Q . front (); Q . pop (); for ( auto e : G [ u ]) { if ( e . cap == 0 || ~ dep [ e . to ]) continue ; dep [ e . to ] = dep [ u ] + 1 ; if ( e . to == T ) return true ; Q . emplace ( e . to ); } } return false ; }; auto DFS = [ & ]( auto self , int u , Cap flow ) { if ( u == T ) return flow ; Cap used = 0 ; for ( int & i = cur [ u ]; i < ( int ) G [ u ]. size (); i ++ ) { auto & e = G [ u ][ i ], & re = G [ e . to ][ e . rev ]; if ( dep [ e . to ] == dep [ u ] + 1 && e . cap ) { Cap d = self ( self , e . to , min ( flow - used , e . cap )); if ( d > 0 ) e . cap -= d , re . cap += d , used += d ; else dep [ e . to ] = -1 ; if ( flow == used ) break ; } } return used ; }; while ( flow < lim && BFS ()) { for ( int i = 0 ; i < n ; i ++ ) cur [ i ] = 0 ; Cap f = DFS ( DFS , S , lim - flow ); if ( ! f ) break ; flow += f ; } return flow ; } vector < bool > Min_Cut ( int S ) { vector < bool > vis ( n ); queue < int > Q ; Q . emplace ( S ), vis [ S ] = true ; while ( Q . size ()) { int u = Q . front (); Q . pop (); for ( auto e : G [ u ]) if ( e . cap && ! vis [ e . to ]) vis [ e . to ] = true , Q . emplace ( e . to ); } return vis ; } };","title":"\u6700\u5927\u6d41"},{"location":"Graph/Flow/#\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 template < class Cap , class Cost > struct MCMF_Graph { public : struct Edge { int u , v ; Cap cap , flow ; Cost cost ; }; constexpr MCMF_Graph () : n ( 0 ) {} explicit constexpr MCMF_Graph ( int _n ) : n ( _n ) {} constexpr int Add_Edge ( int u , int v , Cap cap , Cost cost ) { assert ( 0 <= u && u < n ); assert ( 0 <= v && v < n ); assert ( 0 <= cap ); assert ( 0 <= cost ); const int m = static_cast < int > ( edge . size ()); edge . emplace_back ( u , v , cap , 0 , cost ); return m ; } constexpr Edge Get_Edge ( int i ) { const int m = static_cast < int > ( edge . size ()); assert ( 0 <= i && i < m ); return edge [ i ]; } constexpr vector < Edge > Get_All_Edges () { return edge ; } constexpr pair < Cap , Cost > MCMF ( int S , int T ) { return MCMF ( S , T , numeric_limits < Cap >:: max ()); } constexpr pair < Cap , Cost > MCMF ( int S , int T , Cap lim ) { return Slope ( S , T , lim ). back (); } constexpr vector < pair < Cap , Cost >> Slope ( int S , int T ) { return Slope ( S , T , numeric_limits < Cap >:: max ()); } constexpr vector < pair < Cap , Cost >> Slope ( int S , int T , Cap lim ) { assert ( 0 <= S && S < n ); assert ( 0 <= T && T < n ); assert ( S != T ); const int m = static_cast < int > ( edge . size ()); vector < int > idx ( m ), rev ( m ), deg ( n ); vector < pair < int , _Edge >> elist ( 2 * m ); for ( int i = 0 ; i < m ; i ++ ) { auto e = edge [ i ]; idx [ i ] = deg [ e . u ] ++ ; rev [ i ] = deg [ e . v ] ++ ; elist [ i * 2 ] = { e . u , { e . v , -1 , e . cap - e . flow , e . cost }}; elist [ i * 2 + 1 ] = { e . v , { e . u , -1 , e . flow , - e . cost }}; } auto G = Graph ( n , elist ); for ( int i = 0 ; i < m ; i ++ ) { auto e = edge [ i ]; idx [ i ] += G . head [ e . u ]; rev [ i ] += G . head [ e . v ]; G . elist [ idx [ i ]]. rev = rev [ i ]; G . elist [ rev [ i ]]. rev = idx [ i ]; } auto ans = Slope ( G , S , T , lim ); for ( int i = 0 ; i < m ; i ++ ) { auto e = G . elist [ idx [ i ]]; edge [ i ]. flow = edge [ i ]. cap - e . cap ; } return ans ; } private : int n ; vector < Edge > edge ; struct _Edge { int to , rev ; Cap cap ; Cost cost ; }; struct Graph { vector < int > head ; vector < _Edge > elist ; explicit constexpr Graph ( int n , const vector < pair < int , _Edge >>& edges ) : head ( n + 1 ), elist ( edges . size ()) { for ( auto e : edges ) { ++ head [ e . first + 1 ]; } for ( int i = 1 ; i <= n ; i ++ ) { head [ i ] += head [ i - 1 ]; } auto cnt = head ; for ( auto e : edges ) { elist [ cnt [ e . first ] ++ ] = e . second ; } } }; constexpr vector < pair < Cap , Cost >> Slope ( Graph & G , int S , int T , Cap lim ) { struct Element { Cost cost ; int to ; constexpr bool operator < ( const Element & rhs ) const { return cost > rhs . cost ; } }; const Cost inf = numeric_limits < Cost >:: max (); vector < Cost > dual ( n ), dist ( n ); vector < int > pre ( n ), Qmn ; vector < bool > vis ( n ); vector < Element > Q ; auto Dijkstra = [ & ]() { fill ( dist . begin (), dist . end (), inf ); fill ( vis . begin (), vis . end (), false ); Qmn . clear (), Q . clear (); size_t tl = 0 ; dist [ S ] = 0 ; Qmn . emplace_back ( S ); while ( Qmn . size () || Q . size ()) { int u ; if ( Qmn . size ()) { u = Qmn . back (); Qmn . pop_back (); } else { while ( tl < Q . size ()) { push_heap ( Q . begin (), Q . begin () + ( ++ tl )); } u = Q . front (). to ; pop_heap ( Q . begin (), Q . end ()); Q . pop_back (), -- tl ; } if ( vis [ u ]) { continue ; } vis [ u ] = true ; if ( u == T ) { break ; } Cost dual_u = dual [ u ], dist_u = dist [ u ]; for ( int i = G . head [ u ]; i < G . head [ u + 1 ]; i ++ ) { auto e = G . elist [ i ]; if ( ! e . cap ) { continue ; } Cost cost = e . cost - dual [ e . to ] + dual_u ; if ( dist_u + cost < dist [ e . to ]) { Cost dist_v = dist_u + cost ; dist [ e . to ] = dist_v , pre [ e . to ] = e . rev ; if ( dist_v == dist_u ) { Qmn . emplace_back ( e . to ); } else { Q . emplace_back ( dist_v , e . to ); } } } } if ( ! vis [ T ]) { return false ; } for ( int u = 0 ; u < n ; u ++ ) { if ( ! vis [ u ]) { continue ; } dual [ u ] -= dist [ T ] - dist [ u ]; } return true ; }; Cap flow = 0 ; Cost cost = 0 , pre_slope = -1 ; vector < pair < Cap , Cost >> slope = {{ Cap ( 0 ), Cost ( 0 )}}; while ( flow < lim && Dijkstra ()) { Cap c = lim - flow ; Cost d = - dual [ S ]; for ( int u = T ; u != S ; u = G . elist [ pre [ u ]]. to ) { c = min ( c , G . elist [ G . elist [ pre [ u ]]. rev ]. cap ); } for ( int u = T ; u != S ; u = G . elist [ pre [ u ]]. to ) { auto & e = G . elist [ pre [ u ]]; e . cap += c , G . elist [ e . rev ]. cap -= c ; } flow += c , cost += c * d ; if ( pre_slope == d ) { slope . back () = { flow , cost }; } else { slope . emplace_back ( flow , cost ); } pre_slope = d ; } return slope ; } };","title":"\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41"},{"location":"Graph/GraphBase/","text":"\u7528\u4e8e\u79bb\u7ebf\u5feb\u901f\u5b58\u56fe\u3002 graph<T, directed> \uff1a T \u4e3a\u8fb9\u6743\u7c7b\u578b\uff0c directed \u8868\u793a\u662f\u5426\u6709\u5411\u3002 \u53ef\u4ee5\u901a\u8fc7 addEdge(u, v, cost, id) \u52a0\u8fb9\uff0c build() \u79bb\u7ebf\u5efa\u56fe\u3002 operator [] \u63d0\u4f9b\u4e86\u904d\u5386\u4e00\u4e2a\u70b9\u51fa\u8fb9\u7684\u65b9\u5f0f\u3002 degArray(), IOdegArray(), deg(), indeg(), outdeg() \u53ef\u4ee5\u6c42\u51fa\u6bcf\u4e2a\u70b9\u7684\u5ea6\u6570\u3001\u5165\u5ea6\u3001\u51fa\u5ea6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 namespace graphBase { template < class T > struct edge { int u , v ; T cost ; int id ; edge rev () const { return { v , u , cost , id }; } }; template < class T = int , bool directed = false > struct graph { public : static constexpr bool is_directed = directed ; int n , m ; std :: vector < edge < T >> edges ; std :: vector < int > head ; std :: vector < edge < T >> csr_edges ; private : std :: vector < int > deg_ , indeg_ , outdeg_ ; bool prepared ; struct edgeList { using iter = std :: vector < edge < T >>:: iterator ; private : iter begin_ , end_ ; public : edgeList ( iter begin , iter end ) : begin_ ( begin ), end_ ( end ) {} iter begin () const { return begin_ ; } iter end () const { return end_ ; } auto size () const { return std :: distance ( begin_ , end_ ); } bool empty () const { return ! size (); } edge < T >& operator [] ( int i ) const { return begin_ [ i ]; } }; struct edgeListConst { using iter = std :: vector < edge < T >>:: const_iterator ; private : iter begin_ , end_ ; public : edgeListConst ( iter begin , iter end ) : begin_ ( begin ), end_ ( end ) {} iter begin () const { return begin_ ; } iter end () const { return end_ ; } auto size () const { return std :: distance ( begin_ , end_ ); } bool empty () const { return ! size (); } const edge < T >& operator [] ( int i ) const { return begin_ [ i ]; } }; public : bool is_prepared () const { return prepared ; } graph () : n ( 0 ), m ( 0 ), deg_ {}, indeg_ {}, outdeg_ {}, prepared ( false ) {} graph ( int n ) : n ( n ), m ( 0 ), deg_ {}, indeg_ {}, outdeg_ {}, prepared ( false ) {} graph ( int n_ , const std :: vector < edge < T >>& es , const int offset = 1 ) : n ( n_ ), m ( es . size ()), edges ( es ), deg_ {}, indeg_ {}, outdeg_ {}, prepared ( false ) { for ( auto & e : edges ) { e . u -= offset , e . v -= offset ; } build (); } void addEdge ( int u , int v , T cost = 1 , int id = -1 ) { assert ( ! prepared ); assert ( 0 <= u && u < n ); assert ( 0 <= v && v < n ); if ( id == -1 ) { id = m ; } edges . emplace_back ( u , v , cost , id ); ++ m ; } void build () { assert ( ! prepared ); prepared = true ; head . assign ( n + 1 , 0 ); for ( auto && e : edges ) { ++ head [ e . u + 1 ]; if constexpr ( ! is_directed ) { ++ head [ e . v + 1 ]; } } for ( int u = 0 ; u < n ; u ++ ) { head [ u + 1 ] += head [ u ]; } auto ptr = head ; csr_edges . resize ( head . back () + 1 ); for ( auto && e : edges ) { csr_edges [ ptr [ e . u ] ++ ] = e ; if constexpr ( ! is_directed ) { csr_edges [ ptr [ e . v ] ++ ] = e . rev (); } } } edgeList operator [] ( int u ) { assert ( prepared ); assert ( 0 <= u && u < n ); return { csr_edges . begin () + head [ u ], csr_edges . begin () + head [ u + 1 ]}; } edgeListConst operator [] ( int u ) const { assert ( prepared ); assert ( 0 <= u && u < n ); return { csr_edges . begin () + head [ u ], csr_edges . begin () + head [ u + 1 ]}; } private : void degArray_ () { assert ( prepared ); assert ( deg_ . empty ()); deg_ . resize ( n ); for ( auto && e : edges ) { ++ deg_ [ e . u ], ++ deg_ [ e . v ]; } } void IOdegArray_ () { assert ( prepared ); assert ( indeg_ . empty ()); assert ( outdeg_ . empty ()); indeg_ . resize ( n ); outdeg_ . resize ( n ); for ( auto && e : edges ) { ++ indeg_ [ e . v ]; ++ outdeg_ [ e . u ]; } } public : std :: vector < int > degArray () { if ( deg_ . empty ()) { degArray_ (); } return deg_ ; } std :: pair < std :: vector < int > , std :: vector < int >> IOdegArray () { if ( indeg_ . empty ()) { IOdegArray_ (); } return { indeg_ , outdeg_ }; } int deg ( int u ) { assert ( 0 <= u && u < n ); if ( deg_ . empty ()) { degArray_ (); } return deg_ [ u ]; } int indeg ( int u ) { assert ( 0 <= u && u < n ); if ( indeg_ . empty ()) { IOdegArray_ (); } return indeg_ [ u ]; } int outdeg ( int u ) { assert ( 0 <= u && u < n ); if ( outdeg_ . empty ()) { IOdegArray_ (); } return outdeg_ [ u ]; } }; } using namespace graphBase ;","title":"\u56fe"},{"location":"Graph/st-Numbering/","text":"\u53cc\u6781\u5b9a\u5411 \u5bf9\u4e8e\u56fe \\(G = (V, E)\\) \uff0c\u4ee5\u53ca \\(s, t \\in V\\) \uff0c\u4ee5\u4e0b\u56db\u4e2a\u547d\u9898\u7b49\u4ef7\uff1a \u56fe \\(G' = (V, E \\cup \\{ (s, t) \\})\\) \u70b9\u53cc\u8fde\u901a\u3002 \u5706\u65b9\u6811\u4e0a\u6240\u6709\u65b9\u70b9\u6210\u94fe\uff0c\u5e76\u4e14 \\(s \\rightsquigarrow t\\) \u662f\u5706\u65b9\u6811\u7684\u76f4\u5f84\u3002 \u5b58\u5728 DAG \\(G'\\) \u4ee5 \\(G\\) \u4e3a\u57fa\u56fe\uff0c\u4e14 \\(s\\) \u662f\u552f\u4e00\u5165\u5ea6\u4e3a \\(0\\) \u7684\u70b9\uff0c \\(t\\) \u662f\u552f\u4e00\u51fa\u5ea6\u4e3a \\(0\\) \u7684\u70b9\u3002 \u5b58\u5728 \\(p \\in \\mathfrak S_n\\) \uff0c \\(p_0 = s, p_{n - 1} = t\\) \uff0c\u4efb\u610f\u524d\u540e\u7f00\u5bfc\u51fa\u5b50\u56fe\u8fde\u901a\u3002 st_Numbering(G, s, t) \uff1a\u8fd4\u56de\u56fe \\(G\\) \u4e2d\u6ee1\u8db3 \\(p_0 = s, p_{n - 1} = t\\) \u4e14\u4efb\u610f\u524d\u540e\u7f00\u5bfc\u51fa\u5b50\u56fe\u8fde\u901a\u7684\u6392\u5217 \\(p\\) \u3002 vector \u5b58\u56fe\u7248\u672c\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 std :: vector < int > st_Numbering ( const std :: vector < std :: vector < int >>& adj , const int & s , const int & t ) { const int n = adj . size (); if ( n == 1 ) { return { 0 }; } if ( s == t ) { return {}; } std :: vector < int > dfn ( n , -1 ), fa ( n , -1 ), low ( n , -1 ), ord ( n ); { std :: vector < u32 > head ( n ); int u = t , v , dfc = 2 ; bool reachable = false ; ord [ 0 ] = s , ord [ 1 ] = t ; low [ s ] = dfn [ s ] = 0 ; low [ t ] = dfn [ t ] = 1 ; fa [ t ] = s ; while ( u != s ) { if ( head [ u ] == adj [ u ]. size ()) { v = u , u = fa [ v ]; if ( ~ u ) { low [ u ] = std :: min ( low [ u ], low [ v ]); } continue ; } v = adj [ u ][ head [ u ] ++ ]; if ( v == s ) { reachable = true ; } if ( dfn [ v ] == -1 ) { ord [ dfc ] = v ; low [ v ] = dfn [ v ] = dfc ++ ; fa [ v ] = u , u = v ; continue ; } low [ u ] = std :: min ( low [ u ], dfn [ v ]); } if ( ! reachable || dfc < n ) { return {}; } }; std :: vector < bool > sgn ( n ); std :: vector < int > L ( n ), R ; std :: iota ( L . begin (), L . end (), 0 ), R = L ; for ( int i = 1 ; i < n ; i ++ ) { const int u = ord [ i ]; if ( u != t && low [ u ] == dfn [ fa [ u ]]) { return {}; } if ( sgn [ ord [ low [ u ]]]) { const int v = L [ fa [ u ]]; L [ u ] = v , R [ v ] = u ; R [ u ] = fa [ u ], L [ fa [ u ]] = u ; sgn [ fa [ u ]] = false ; } else { const int v = R [ fa [ u ]]; R [ u ] = v , L [ v ] = u ; L [ u ] = fa [ u ], R [ fa [ u ]] = u ; sgn [ fa [ u ]] = true ; } } std :: vector < int > p ( n ); ord [ 0 ] = s ; for ( int i = 1 ; i < n ; i ++ ) { ord [ i ] = R [ ord [ i - 1 ]]; } for ( int i = 0 ; i < n ; i ++ ) { p [ ord [ i ]] = i ; } return p ; } graph \u5b58\u56fe\u7248\u672c\uff08\u9700\u524d\u7f6e GraphBase \uff09\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 template < class Graph > std :: vector < int > st_Numbering ( const Graph & G , const int & s , const int & t ) { assert ( ! G . is_directed ); assert ( G . is_prepared ()); const int n = G . n ; if ( n == 1 ) { return { 0 }; } if ( s == t ) { return {}; } std :: vector < int > dfn ( n , -1 ), fa ( n , -1 ), low ( n , -1 ), ord ( n ); { auto head = G . head ; int u = t , v , dfc = 2 ; bool reachable = false ; ord [ 0 ] = s , ord [ 1 ] = t ; low [ s ] = dfn [ s ] = 0 ; low [ t ] = dfn [ t ] = 1 ; fa [ t ] = s ; while ( u != s ) { if ( head [ u ] == G . head [ u + 1 ]) { v = u , u = fa [ v ]; if ( ~ u ) { low [ u ] = std :: min ( low [ u ], low [ v ]); } continue ; } v = G . csr_edges [ head [ u ] ++ ]. v ; if ( v == s ) { reachable = true ; } if ( dfn [ v ] == -1 ) { ord [ dfc ] = v ; low [ v ] = dfn [ v ] = dfc ++ ; fa [ v ] = u , u = v ; continue ; } low [ u ] = std :: min ( low [ u ], dfn [ v ]); } if ( ! reachable || dfc < n ) { return {}; } }; std :: vector < bool > sgn ( n ); std :: vector < int > L ( n ), R ; std :: iota ( L . begin (), L . end (), 0 ), R = L ; for ( int i = 1 ; i < n ; i ++ ) { const int u = ord [ i ]; if ( u != t && low [ u ] == dfn [ fa [ u ]]) { return {}; } if ( sgn [ ord [ low [ u ]]]) { const int v = L [ fa [ u ]]; L [ u ] = v , R [ v ] = u ; R [ u ] = fa [ u ], L [ fa [ u ]] = u ; sgn [ fa [ u ]] = false ; } else { const int v = R [ fa [ u ]]; R [ u ] = v , L [ v ] = u ; L [ u ] = fa [ u ], R [ fa [ u ]] = u ; sgn [ fa [ u ]] = true ; } } std :: vector < int > p ( n ); ord [ 0 ] = s ; for ( int i = 1 ; i < n ; i ++ ) { ord [ i ] = R [ ord [ i - 1 ]]; } for ( int i = 0 ; i < n ; i ++ ) { p [ ord [ i ]] = i ; } return p ; }","title":"\u53cc\u6781\u5b9a\u5411"},{"location":"Graph/st-Numbering/#\u53cc\u6781\u5b9a\u5411","text":"\u5bf9\u4e8e\u56fe \\(G = (V, E)\\) \uff0c\u4ee5\u53ca \\(s, t \\in V\\) \uff0c\u4ee5\u4e0b\u56db\u4e2a\u547d\u9898\u7b49\u4ef7\uff1a \u56fe \\(G' = (V, E \\cup \\{ (s, t) \\})\\) \u70b9\u53cc\u8fde\u901a\u3002 \u5706\u65b9\u6811\u4e0a\u6240\u6709\u65b9\u70b9\u6210\u94fe\uff0c\u5e76\u4e14 \\(s \\rightsquigarrow t\\) \u662f\u5706\u65b9\u6811\u7684\u76f4\u5f84\u3002 \u5b58\u5728 DAG \\(G'\\) \u4ee5 \\(G\\) \u4e3a\u57fa\u56fe\uff0c\u4e14 \\(s\\) \u662f\u552f\u4e00\u5165\u5ea6\u4e3a \\(0\\) \u7684\u70b9\uff0c \\(t\\) \u662f\u552f\u4e00\u51fa\u5ea6\u4e3a \\(0\\) \u7684\u70b9\u3002 \u5b58\u5728 \\(p \\in \\mathfrak S_n\\) \uff0c \\(p_0 = s, p_{n - 1} = t\\) \uff0c\u4efb\u610f\u524d\u540e\u7f00\u5bfc\u51fa\u5b50\u56fe\u8fde\u901a\u3002 st_Numbering(G, s, t) \uff1a\u8fd4\u56de\u56fe \\(G\\) \u4e2d\u6ee1\u8db3 \\(p_0 = s, p_{n - 1} = t\\) \u4e14\u4efb\u610f\u524d\u540e\u7f00\u5bfc\u51fa\u5b50\u56fe\u8fde\u901a\u7684\u6392\u5217 \\(p\\) \u3002 vector \u5b58\u56fe\u7248\u672c\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 std :: vector < int > st_Numbering ( const std :: vector < std :: vector < int >>& adj , const int & s , const int & t ) { const int n = adj . size (); if ( n == 1 ) { return { 0 }; } if ( s == t ) { return {}; } std :: vector < int > dfn ( n , -1 ), fa ( n , -1 ), low ( n , -1 ), ord ( n ); { std :: vector < u32 > head ( n ); int u = t , v , dfc = 2 ; bool reachable = false ; ord [ 0 ] = s , ord [ 1 ] = t ; low [ s ] = dfn [ s ] = 0 ; low [ t ] = dfn [ t ] = 1 ; fa [ t ] = s ; while ( u != s ) { if ( head [ u ] == adj [ u ]. size ()) { v = u , u = fa [ v ]; if ( ~ u ) { low [ u ] = std :: min ( low [ u ], low [ v ]); } continue ; } v = adj [ u ][ head [ u ] ++ ]; if ( v == s ) { reachable = true ; } if ( dfn [ v ] == -1 ) { ord [ dfc ] = v ; low [ v ] = dfn [ v ] = dfc ++ ; fa [ v ] = u , u = v ; continue ; } low [ u ] = std :: min ( low [ u ], dfn [ v ]); } if ( ! reachable || dfc < n ) { return {}; } }; std :: vector < bool > sgn ( n ); std :: vector < int > L ( n ), R ; std :: iota ( L . begin (), L . end (), 0 ), R = L ; for ( int i = 1 ; i < n ; i ++ ) { const int u = ord [ i ]; if ( u != t && low [ u ] == dfn [ fa [ u ]]) { return {}; } if ( sgn [ ord [ low [ u ]]]) { const int v = L [ fa [ u ]]; L [ u ] = v , R [ v ] = u ; R [ u ] = fa [ u ], L [ fa [ u ]] = u ; sgn [ fa [ u ]] = false ; } else { const int v = R [ fa [ u ]]; R [ u ] = v , L [ v ] = u ; L [ u ] = fa [ u ], R [ fa [ u ]] = u ; sgn [ fa [ u ]] = true ; } } std :: vector < int > p ( n ); ord [ 0 ] = s ; for ( int i = 1 ; i < n ; i ++ ) { ord [ i ] = R [ ord [ i - 1 ]]; } for ( int i = 0 ; i < n ; i ++ ) { p [ ord [ i ]] = i ; } return p ; } graph \u5b58\u56fe\u7248\u672c\uff08\u9700\u524d\u7f6e GraphBase \uff09\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 template < class Graph > std :: vector < int > st_Numbering ( const Graph & G , const int & s , const int & t ) { assert ( ! G . is_directed ); assert ( G . is_prepared ()); const int n = G . n ; if ( n == 1 ) { return { 0 }; } if ( s == t ) { return {}; } std :: vector < int > dfn ( n , -1 ), fa ( n , -1 ), low ( n , -1 ), ord ( n ); { auto head = G . head ; int u = t , v , dfc = 2 ; bool reachable = false ; ord [ 0 ] = s , ord [ 1 ] = t ; low [ s ] = dfn [ s ] = 0 ; low [ t ] = dfn [ t ] = 1 ; fa [ t ] = s ; while ( u != s ) { if ( head [ u ] == G . head [ u + 1 ]) { v = u , u = fa [ v ]; if ( ~ u ) { low [ u ] = std :: min ( low [ u ], low [ v ]); } continue ; } v = G . csr_edges [ head [ u ] ++ ]. v ; if ( v == s ) { reachable = true ; } if ( dfn [ v ] == -1 ) { ord [ dfc ] = v ; low [ v ] = dfn [ v ] = dfc ++ ; fa [ v ] = u , u = v ; continue ; } low [ u ] = std :: min ( low [ u ], dfn [ v ]); } if ( ! reachable || dfc < n ) { return {}; } }; std :: vector < bool > sgn ( n ); std :: vector < int > L ( n ), R ; std :: iota ( L . begin (), L . end (), 0 ), R = L ; for ( int i = 1 ; i < n ; i ++ ) { const int u = ord [ i ]; if ( u != t && low [ u ] == dfn [ fa [ u ]]) { return {}; } if ( sgn [ ord [ low [ u ]]]) { const int v = L [ fa [ u ]]; L [ u ] = v , R [ v ] = u ; R [ u ] = fa [ u ], L [ fa [ u ]] = u ; sgn [ fa [ u ]] = false ; } else { const int v = R [ fa [ u ]]; R [ u ] = v , L [ v ] = u ; L [ u ] = fa [ u ], R [ fa [ u ]] = u ; sgn [ fa [ u ]] = true ; } } std :: vector < int > p ( n ); ord [ 0 ] = s ; for ( int i = 1 ; i < n ; i ++ ) { ord [ i ] = R [ ord [ i - 1 ]]; } for ( int i = 0 ; i < n ; i ++ ) { p [ ord [ i ]] = i ; } return p ; }","title":"\u53cc\u6781\u5b9a\u5411"},{"location":"Math/Combinatorics/Combination/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 struct Combination { int N ; vector < Z > _fac , _ifac , _inv ; Combination ( int n ) : N ( 0 ), _fac { 1 }, _ifac { 1 }, _inv { 0 } { Init ( n ); } Combination () : N ( 0 ), _fac { 1 }, _ifac { 1 }, _inv { 0 } {} void Init ( int n ) { if ( n <= N ) return ; _fac . resize ( n + 1 ), _ifac . resize ( n + 1 ), _inv . resize ( n + 1 ); for ( int i = N + 1 ; i <= n ; i ++ ) _fac [ i ] = _fac [ i - 1 ] * i ; _ifac [ n ] = _fac [ n ]. inv (); for ( int i = n ; i > N ; i -- ) _ifac [ i - 1 ] = _ifac [ i ] * i , _inv [ i ] = _ifac [ i ] * _fac [ i - 1 ]; N = n ; return ; } Z fac ( int n ) { if ( n > N ) Init ( n << 1 ); return _fac [ n ]; } Z ifac ( int n ) { if ( n > N ) Init ( n << 1 ); return _ifac [ n ]; } Z inv ( int n ) { if ( n > N ) Init ( n << 1 ); return _inv [ n ]; } Z binom ( int n , int m ) { if ( n < m || n < 0 || m < 0 ) return 0 ; return fac ( n ) * ifac ( m ) * ifac ( n - m ); } } comb ;","title":"\u7ec4\u5408\u6570\u9884\u5904\u7406"},{"location":"Math/Combinatorics/DynamicModint/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 template < class U0 , class U1 > struct Montgomery { constexpr static unsigned B0 = sizeof ( U0 ) * 8U ; U0 n , nr , rs , np ; constexpr Montgomery ( const U0 & Mod ) { SetMod ( Mod ); } constexpr U0 GetMod () const noexcept { return n ; } constexpr void SetMod ( const U0 & Mod ) { assert ( Mod >= 2 ), assert ( Mod % 2 == 1 ); assert (( Mod >> ( B0 - 2 )) == 0 ); n = nr = Mod , rs = - static_cast < U1 > ( n ) % n ; for ( u32 i = 0 ; i < __lg ( B0 ); i ++ ) { nr *= 2 - n * nr ; } np = Reduce ( static_cast < U0 > ( 1 ), rs ); } constexpr U0 Reduce ( const U0 & x ) const noexcept { const U0 q = x * nr ; const U0 m = ( static_cast < U1 > ( q ) * n ) >> B0 ; return n - m ; } constexpr U0 Reduce ( const U0 & x , const U0 & y ) const noexcept { const U1 t = static_cast < U1 > ( x ) * y ; const U0 c = t , d = t >> B0 ; const U0 q = c * nr ; const U0 m = ( static_cast < U1 > ( q ) * n ) >> B0 ; return d + n - m ; } constexpr U0 Reduce ( const U0 & x , const U0 & y , const U0 & z ) const noexcept { const U1 t = static_cast < U1 > ( x ) * y ; const U0 c = t , d = t >> B0 ; const U0 q = c * nr ; const U0 m = ( static_cast < U1 > ( q ) * n ) >> B0 ; return z + d + n - m ; } constexpr U0 val ( const U0 & x ) const noexcept { const u64 t = Reduce ( x ); return ( t == n ) ? static_cast < U0 > ( 0 ) : t ; } constexpr U0 zero () const noexcept { return static_cast < U0 > ( 0 ); } constexpr U0 one () const noexcept { return np ; } constexpr U0 raw ( const U0 & x ) const noexcept { return Reduce ( x , rs ); } template < class T > constexpr U0 trans ( T x ) const noexcept { if ( __builtin_expect ( static_cast < T > ( 0 ) <= x && x < static_cast < T > ( n ), 1 )) { return raw ( static_cast < U0 > ( x )); } if constexpr ( is_unsigned < T >:: value ) { x %= static_cast < T > ( n ); } else { if (( x %= static_cast < T > ( n )) < 0 ) { ( x += static_cast < T > ( n )) %= static_cast < T > ( n ); } } return Reduce ( static_cast < U0 > ( x ), rs ); } constexpr U0 neg ( const U0 & x ) const noexcept { return ( x != 0 ) ? ( 2 * n - x ) : x ; } constexpr U0 inc ( const U0 & x ) const noexcept { return add ( x , np ); } constexpr U0 dec ( const U0 & x ) const noexcept { return sub ( x , np ); } constexpr U0 add ( const U0 & x , const U0 & y ) const noexcept { return ( x + y >= 2 * n ) ? ( x + y - 2 * n ) : ( x + y ); } constexpr U0 sub ( const U0 & x , const U0 & y ) const noexcept { return ( x < y ) ? ( x - y + 2 * n ) : ( x - y ); } constexpr U0 mul ( const U0 & x , const U0 & y ) const noexcept { return Reduce ( x , y ); } constexpr U0 mul_add ( const U0 & x , const U0 & y , const U0 & z ) const noexcept { return Reduce ( x , y , z ); } constexpr bool same ( const U0 & x , const U0 & y ) const noexcept { const U0 dif = x - y ; return ( dif == 0 ) || ( dif == n ) || ( dif == - n ); } }; template < class U0 , class U1 , class S0 , unsigned P > struct Dynamic_Modint { private : static inline Montgomery < U0 , U1 > Mod = P ; U0 x ; public : constexpr Dynamic_Modint () : x ( Mod . zero ()) {} template < class T > constexpr Dynamic_Modint ( T _x ) : x ( Mod . trans ( _x )) {} static constexpr Dynamic_Modint raw ( U0 _x ) { Dynamic_Modint x ; return x . x = Mod . raw ( _x ), x ; } static constexpr U0 GetMod () { return Mod . GetMod (); } static constexpr void SetMod ( U0 Mod_ ) { return Mod . SetMod ( Mod_ ); } template < class T > explicit constexpr operator T () const { return static_cast < T > ( Mod . val ( x )); } constexpr Dynamic_Modint & operator += ( const Dynamic_Modint & rhs ) { x = Mod . add ( x , rhs . x ); return * this ; } constexpr Dynamic_Modint & operator -= ( const Dynamic_Modint & rhs ) { x = Mod . sub ( x , rhs . x ); return * this ; } constexpr Dynamic_Modint & operator *= ( const Dynamic_Modint & rhs ) { x = Mod . mul ( x , rhs . x ); return * this ; } constexpr Dynamic_Modint & operator /= ( const Dynamic_Modint & rhs ) { return ( * this *= rhs . inv ()); } constexpr Dynamic_Modint inv () const { U0 a = GetMod (), b = Mod . val ( x ); S0 y = 0 , z = 1 ; while ( b ) { const U0 q = a / b ; const U0 c = a - q * b ; a = b , b = c ; const S0 w = y - static_cast < S0 > ( q ) * z ; y = z , z = w ; } return raw (( y < 0 ) ? ( y + GetMod ()) : y ); } friend constexpr Dynamic_Modint operator + ( const Dynamic_Modint & x ) { return x ; } friend constexpr Dynamic_Modint operator - ( Dynamic_Modint x ) { return x . x = Mod . neg ( x . x ), x ; } constexpr Dynamic_Modint & operator ++ () { x = Mod . inc ( x ); return * this ; } constexpr Dynamic_Modint & operator -- () { x = Mod . dec ( x ); return * this ; } constexpr Dynamic_Modint operator ++ ( int ) { Dynamic_Modint t = ( * this ); return ++ ( * this ), t ; } constexpr Dynamic_Modint operator -- ( int ) { Dynamic_Modint t = ( * this ); return -- ( * this ), t ; } friend constexpr Dynamic_Modint operator + ( Dynamic_Modint x , const Dynamic_Modint & y ) { return x += y ; } friend constexpr Dynamic_Modint operator - ( Dynamic_Modint x , const Dynamic_Modint & y ) { return x -= y ; } friend constexpr Dynamic_Modint operator * ( Dynamic_Modint x , const Dynamic_Modint & y ) { return x *= y ; } friend constexpr Dynamic_Modint operator / ( Dynamic_Modint x , const Dynamic_Modint & y ) { return x /= y ; } constexpr Dynamic_Modint Pow ( long long y ) const { if ( y < 0 ) return inv (). Pow ( - y ); Dynamic_Modint x = * this , ans ; ans . x = Mod . one (); for (; y ; y >>= 1 , x *= x ) if ( y & 1 ) ans *= x ; return ans ; } friend ostream & operator << ( ostream & os , const Dynamic_Modint & x ) { return os << Mod . val ( x . x ); } friend constexpr bool operator == ( const Dynamic_Modint & x , const Dynamic_Modint & y ) { return Mod . same ( x . x , y . x ); } friend constexpr bool operator != ( const Dynamic_Modint & x , const Dynamic_Modint & y ) { return ! ( x == y ); } friend constexpr bool operator <= ( const Dynamic_Modint & x , const Dynamic_Modint & y ) { return Mod . val ( x . x ) <= Mod . val ( y . x ); } friend constexpr bool operator >= ( const Dynamic_Modint & x , const Dynamic_Modint & y ) { return Mod . val ( x . x ) >= Mod . val ( y . x ); } friend constexpr bool operator < ( const Dynamic_Modint & x , const Dynamic_Modint & y ) { return Mod . val ( x . x ) < Mod . val ( y . x ); } friend constexpr bool operator > ( const Dynamic_Modint & x , const Dynamic_Modint & y ) { return Mod . val ( x . x ) > Mod . val ( y . x ); } }; template < u32 P > using dm32 = Dynamic_Modint < u32 , u64 , int , P > ; template < u64 P > using dm64 = Dynamic_Modint < u64 , u128 , i64 , P > ; using Z = dm32 < MOD > ;","title":"\u52a8\u6001\u53d6\u6a21\u7c7b"},{"location":"Math/Combinatorics/FastMod/","text":"\u7528\u6765\u5047\u88c5\u81ea\u5df1\u6ca1\u8d3a\u677f\u5b50\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 constexpr u32 add ( const u32 & x , const u32 & y , const u32 & M = Mod ) { return ( x + y >= M ) ? ( x + y - M ) : ( x + y ); } constexpr u32 sub ( const u32 & x , const u32 & y , const u32 & M = Mod ) { return ( x - y >= M ) ? ( x - y + M ) : ( x - y ); } constexpr u32 mul ( const u32 & x , const u32 & y , const u32 & M = Mod ) { return static_cast < u32 > ( static_cast < u64 > ( x ) * y % static_cast < u64 > ( M )); } constexpr u32 & cadd ( u32 & x , const u32 & y , const u32 & M = Mod ) { return x = add ( x , y , M ); } constexpr u32 & csub ( u32 & x , const u32 & y , const u32 & M = Mod ) { return x = sub ( x , y , M ); } constexpr u32 & cmul ( u32 & x , const u32 & y , const u32 & M = Mod ) { return x = mul ( x , y , M ); }","title":"\u5feb\u901f\u53d6\u6a21"},{"location":"Math/Combinatorics/StaticModint/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 template < class U0 , class U1 , class S0 , U0 P > struct Static_Modint { private : static_assert (( P >> ( sizeof ( U0 ) * 8 - 1 )) == 0 , \"'Mod' must less than max(U0)/2\" ); static constexpr U0 Mod = P ; U0 x ; template < class T > static constexpr unsigned SafeMod ( T x ) { if constexpr ( std :: is_unsigned < T >:: value ) { x %= static_cast < T > ( Mod ); return static_cast < U0 > ( x ); } else { if (( x %= static_cast < T > ( Mod )) < 0 ) x += static_cast < T > ( Mod ); return static_cast < U0 > ( x ); } } public : constexpr Static_Modint () : x ( static_cast < U0 > ( 0 )) {} template < class T > constexpr Static_Modint ( T _x ) : x ( SafeMod ( _x )) {} static constexpr Static_Modint raw ( U0 _x ) noexcept { Static_Modint x ; return x . x = _x , x ; } static constexpr U0 GetMod () { return Mod ; } template < class T > explicit constexpr operator T () const { return static_cast < T > ( x ); } constexpr Static_Modint & operator += ( const Static_Modint & rhs ) { x = (( x += rhs . x ) >= Mod ) ? ( x - Mod ) : x ; return * this ; } constexpr Static_Modint & operator -= ( const Static_Modint & rhs ) { x = (( x -= rhs . x ) >= Mod ) ? ( x + Mod ) : x ; return * this ; } constexpr Static_Modint & operator *= ( const Static_Modint & rhs ) { x = ( static_cast < U1 > ( x ) * rhs . x ) % Mod ; return * this ; } constexpr Static_Modint & operator /= ( const Static_Modint & rhs ) { return ( * this *= rhs . inv ()); } friend constexpr Static_Modint fma ( const Static_Modint & a , const Static_Modint & b , const Static_Modint & c ) { return raw (( static_cast < U1 > ( a . x ) * b . x + c . x ) % Mod ); } friend constexpr Static_Modint fam ( const Static_Modint & a , const Static_Modint & b , const Static_Modint & c ) { return raw (( a . x + static_cast < U1 > ( b . x ) * c . x ) % Mod ); } friend constexpr Static_Modint fms ( const Static_Modint & a , const Static_Modint & b , const Static_Modint & c ) { return raw (( static_cast < U1 > ( a . x ) * b . x + Mod - c . x ) % Mod ); } friend constexpr Static_Modint fsm ( const Static_Modint & a , const Static_Modint & b , const Static_Modint & c ) { return raw (( a . x + static_cast < U1 > ( Mod - b . x ) * c . x ) % Mod ); } constexpr Static_Modint div_2 () const { return raw ((( x & 1 ) ? ( x + Mod ) : x ) >> 1 ); } constexpr Static_Modint inv () const { U0 a = Mod , b = x ; S0 y = 0 , z = 1 ; while ( b ) { const U0 q = a / b ; const U0 c = a - q * b ; a = b , b = c ; const S0 w = y - static_cast < S0 > ( q ) * z ; y = z , z = w ; } return raw ( y < 0 ? y + Mod : y ); } friend constexpr Static_Modint operator + ( const Static_Modint & x ) { return x ; } friend constexpr Static_Modint operator - ( Static_Modint x ) { x . x = x . x ? ( Mod - x . x ) : 0U ; return x ; } constexpr Static_Modint & operator ++ () { x = ( x + 1 == Mod ) ? 0U : ( x + 1 ); return * this ; } constexpr Static_Modint & operator -- () { x = ( x == 0U ) ? ( Mod - 1 ) : ( x - 1 ); return * this ; } constexpr Static_Modint operator ++ ( int ) { Static_Modint tmp = ( * this ); return ++ ( * this ), tmp ; } constexpr Static_Modint operator -- ( int ) { Static_Modint tmp = ( * this ); return -- ( * this ), tmp ; } friend constexpr Static_Modint operator + ( Static_Modint x , const Static_Modint & y ) { return x += y ; } friend constexpr Static_Modint operator - ( Static_Modint x , const Static_Modint & y ) { return x -= y ; } friend constexpr Static_Modint operator * ( Static_Modint x , const Static_Modint & y ) { return x *= y ; } friend constexpr Static_Modint operator / ( Static_Modint x , const Static_Modint & y ) { return x /= y ; } constexpr Static_Modint Pow ( long long y ) const { if ( y < 0 ) return inv (). Pow ( - y ); Static_Modint x = * this , ans ; ans . x = static_cast < U0 > ( 1 ); for (; y ; y >>= 1 , x *= x ) if ( y & 1 ) ans *= x ; return ans ; } friend constexpr std :: istream & operator >> ( std :: istream & is , Static_Modint & x ) { return is >> x . x ; } friend constexpr std :: ostream & operator << ( std :: ostream & os , const Static_Modint & x ) { return os << x . x ; } friend constexpr bool operator == ( const Static_Modint & x , const Static_Modint & y ) { return x . x == y . x ; } friend constexpr bool operator != ( const Static_Modint & x , const Static_Modint & y ) { return x . x != y . x ; } friend constexpr bool operator <= ( const Static_Modint & x , const Static_Modint & y ) { return x . x <= y . x ; } friend constexpr bool operator >= ( const Static_Modint & x , const Static_Modint & y ) { return x . x >= y . x ; } friend constexpr bool operator < ( const Static_Modint & x , const Static_Modint & y ) { return x . x < y . x ; } friend constexpr bool operator > ( const Static_Modint & x , const Static_Modint & y ) { return x . x > y . x ; } }; template < u32 P > using sm32 = Static_Modint < u32 , u64 , int , P > ; template < u64 P > using sm64 = Static_Modint < u64 , u128 , i64 , P > ; using Z = sm32 < 998244353U > ;","title":"\u9759\u6001\u53d6\u6a21\u7c7b"},{"location":"Math/LinearAlgebra/CharacteristicPolynomial/","text":"\u5bf9\u4e8e\u4e00\u4e2a\u77e9\u9635 \\(\\mathbf A\\) \uff0c\u53ef\u4ee5\u4f7f\u7528 charPoly(A) \u5728 \\(O(n^3)\\) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5185\u6c42\u51fa \\(\\mathbf A\\) \u7684\u7279\u5f81\u591a\u9879\u5f0f \\(\\det(\\lambda \\mathbf I - \\mathbf A)\\) \u3002 \u5bf9\u4e8e \\(m + 1\\) \u4e2a\u77e9\u9635 \\(\\mathbf A_0, \\cdots, \\mathbf A_m\\) \uff0c\u53ef\u4ee5\u4f7f\u7528 detPoly(A) \u5728 \\(O(n^3m^3)\\) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5185\u6c42\u51fa \\(\\det(\\mathbf A_0 + \\mathbf A_1 x + \\mathbf A_2 x^2 + \\cdots + \\mathbf A_m x^m)\\) \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 std :: vector < Z > charPoly ( std :: vector < std :: vector < Z >> A ) { const size_t n = A . size (); for ( size_t i = 0 ; i < n ; i ++ ) { for ( size_t j = 0 ; j < n ; j ++ ) { A [ i ][ j ] = - A [ i ][ j ]; } } for ( size_t i = 0 ; i + 2 < n ; i ++ ) { size_t pivot = i + 1 ; for (; pivot < n && ! A [ pivot ][ i ]; ++ pivot ); if ( pivot == n ) { continue ; } if ( pivot > i + 1 ) { for ( size_t j = i ; j < n ; j ++ ) { std :: swap ( A [ i + 1 ][ j ], A [ pivot ][ j ]); } for ( size_t j = 0 ; j < n ; j ++ ) { std :: swap ( A [ j ][ i + 1 ], A [ j ][ pivot ]); } } const Z inv = A [ i + 1 ][ i ]. inv (); for ( size_t j = i + 2 ; j < n ; j ++ ) { if ( A [ j ][ i ]) { const Z t = A [ j ][ i ] * inv ; for ( size_t k = i ; k < n ; k ++ ) { A [ j ][ k ] = fsm ( A [ j ][ k ], t , A [ i + 1 ][ k ]); } for ( size_t k = 0 ; k < n ; k ++ ) { A [ k ][ i + 1 ] = fam ( A [ k ][ i + 1 ], t , A [ k ][ j ]); } } } } std :: vector < std :: vector < Z >> dp ( n + 1 ); dp [ 0 ] = { Z ( 1 )}; for ( size_t i = 0 ; i < n ; i ++ ) { dp [ i + 1 ]. assign ( i + 2 , Z ( 0 )); for ( size_t k = 0 ; k <= i ; k ++ ) { dp [ i + 1 ][ k + 1 ] = dp [ i ][ k ]; } for ( size_t k = 0 ; k <= i ; k ++ ) { dp [ i + 1 ][ k ] = fam ( dp [ i + 1 ][ k ], A [ i ][ i ], dp [ i ][ k ]); } Z prod = 1 ; for ( size_t j = i ; j ; j -- ) { prod *= - A [ j ][ j - 1 ]; const Z t = prod * A [ j - 1 ][ i ]; for ( size_t k = 0 ; k < j ; k ++ ) { dp [ i + 1 ][ k ] = fam ( dp [ i + 1 ][ k ], t , dp [ j - 1 ][ k ]); } } } return dp [ n ]; } std :: vector < Z > detPoly ( std :: vector < std :: vector < std :: vector < Z >>> A ) { assert ( A . size ()); const int m = A . size () - 1 , n = A [ 0 ]. size (); Z prod = Z ( 1 ); int offset = 0 ; for ( int h = 0 ; h < n ; h ++ ) { for (; ; ) { if ( A [ m ][ h ][ h ]) { break ; } for ( int j = h + 1 ; j < n ; j ++ ) { if ( A [ m ][ h ][ j ]) { prod = - prod ; for ( int d = 0 ; d <= m ; d ++ ) { for ( int i = 0 ; i < n ; i ++ ) { std :: swap ( A [ d ][ i ][ h ], A [ d ][ i ][ j ]); break ; } } } } if ( A [ m ][ h ][ h ]) { break ; } if ( ++ offset > n * m ) { return std :: vector < Z > ( n * m + 1 , Z ( 0 )); } for ( int d = m ; -- d >= 0 ; ) { for ( int j = 0 ; j < n ; j ++ ) { A [ d + 1 ][ h ][ j ] = A [ d ][ h ][ j ]; } } for ( int j = 0 ; j < n ; j ++ ) { A [ 0 ][ h ][ j ] = Z ( 0 ); } for ( int i = 0 ; i < h ; i ++ ) { const Z t = A [ m ][ h ][ i ]; for ( int d = 0 ; d <= m ; d ++ ) { for ( int j = 0 ; j < n ; j ++ ) { A [ d ][ h ][ j ] -= t * A [ d ][ i ][ j ]; } } } } prod *= A [ m ][ h ][ h ]; const Z inv = A [ m ][ h ][ h ]. inv (); for ( int d = 0 ; d <= m ; d ++ ) { for ( int j = 0 ; j < n ; j ++ ) { A [ d ][ h ][ j ] *= inv ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( h != i ) { const Z t = A [ m ][ i ][ h ]; for ( int d = 0 ; d <= m ; d ++ ) { for ( int j = 0 ; j < n ; j ++ ) { A [ d ][ i ][ j ] -= t * A [ d ][ h ][ j ]; } } } } } std :: vector < std :: vector < Z >> B ( n * m , std :: vector < Z > ( n * m , Z ( 0 ))); for ( int i = 0 ; i < ( m - 1 ) * n ; i ++ ) { B [ i ][ n + i ] = Z ( 1 ); } for ( int d = 0 ; d < m ; d ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { B [( m - 1 ) * n + i ][ d * n + j ] = - A [ d ][ i ][ j ]; } } } const std :: vector < Z > f = charPoly ( B ); std :: vector < Z > g ( n * m + 1 , Z ( 0 )); for ( int i = 0 ; i + offset <= n * m ; i ++ ) { g [ i ] = prod * f [ i + offset ]; } return g ; }","title":"\u7279\u5f81\u591a\u9879\u5f0f"},{"location":"Math/LinearAlgebra/Determinant/","text":"\u884c\u5217\u5f0f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 mint Det ( vector < vector < mint >> a ) { const int n = static_cast < int > ( a . size ()); bool typ = false ; mint det = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int pos = - 1 ; for ( int j = i ; j < n ; j ++ ) { if ( a [ j ][ i ]) { pos = j ; break ; } } if ( !~ pos ) { return 0 ; } if ( pos != i ) { typ ^= 1 ; } swap ( a [ i ], a [ pos ]); for ( int j = i + 1 ; j < n ; j ++ ) { while ( a [ j ][ i ]) { typ ^= 1 ; int coef = ( int ) a [ i ][ i ] / ( int ) a [ j ][ i ]; for ( int k = i ; k < n ; k ++ ) { a [ i ][ k ] -= a [ j ][ k ] * coef , swap ( a [ i ][ k ], a [ j ][ k ]); } } } det *= a [ i ][ i ]; } return typ ? - det : det ; }","title":"\u884c\u5217\u5f0f"},{"location":"Math/LinearAlgebra/Determinant/#\u884c\u5217\u5f0f","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 mint Det ( vector < vector < mint >> a ) { const int n = static_cast < int > ( a . size ()); bool typ = false ; mint det = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int pos = - 1 ; for ( int j = i ; j < n ; j ++ ) { if ( a [ j ][ i ]) { pos = j ; break ; } } if ( !~ pos ) { return 0 ; } if ( pos != i ) { typ ^= 1 ; } swap ( a [ i ], a [ pos ]); for ( int j = i + 1 ; j < n ; j ++ ) { while ( a [ j ][ i ]) { typ ^= 1 ; int coef = ( int ) a [ i ][ i ] / ( int ) a [ j ][ i ]; for ( int k = i ; k < n ; k ++ ) { a [ i ][ k ] -= a [ j ][ k ] * coef , swap ( a [ i ][ k ], a [ j ][ k ]); } } } det *= a [ i ][ i ]; } return typ ? - det : det ; }","title":"\u884c\u5217\u5f0f"},{"location":"Math/LinearAlgebra/Pfaffian/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 Z Pfaffian ( vector < vector < Z >> A ) { const int n = A . size (); assert (( n & 1 ) == 0 ); bool sgn = false ; Z Pf = 1 ; for ( int i = 0 ; i < n ; i += 2 ) { int p = -1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( A [ i ][ j ]) { p = j ; break ; } } if ( p == -1 ) { return 0 ; } if ( p != i + 1 ) { sgn ^= 1 ; for ( int j = 0 ; j < n ; j ++ ) { swap ( A [ j ][ i + 1 ], A [ j ][ p ]); } for ( int j = i + 1 ; j < n ; j ++ ) { swap ( A [ i + 1 ][ j ], A [ p ][ j ]); } } const Z inv = A [ i ][ i + 1 ]. inv (); for ( int j = i + 2 ; j < n ; j ++ ) { if ( A [ i ][ j ]) { const Z coef = - A [ i ][ j ] * inv ; for ( int k = i ; k < n ; k ++ ) { A [ k ][ j ] += A [ k ][ i + 1 ] * coef ; } for ( int k = 0 ; k < n ; k ++ ) { A [ j ][ k ] += A [ i + 1 ][ k ] * coef ; } } } Pf *= A [ i ][ i + 1 ]; } return sgn ? - Pf : Pf ; }","title":"Pfaffian"},{"location":"Math/NumberTheory/Factorize/","text":"\u8d28\u56e0\u6570\u5206\u89e3 Is_Prime \u662f Miller-Rabin \u5224\u65ad\u662f\u5426\u662f\u7d20\u6570\uff0c Factorize \u662f Pollard-Rho \u8d28\u56e0\u6570\u5206\u89e3\uff0c\u8fd4\u56de\u4e00\u4e2a vector<pair<u64, u32>> \uff0c first \u662f\u8d28\u56e0\u6570\uff0c second \u662f\u8d28\u56e0\u6570\u5e42\u6b21\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 template < class U0 , class U1 > struct Montgomery { constexpr static unsigned B0 = sizeof ( U0 ) * 8U ; U0 n , nr , rs , np ; constexpr Montgomery ( const U0 & Mod ) { SetMod ( Mod ); } constexpr U0 GetMod () const noexcept { return n ; } constexpr void SetMod ( const U0 & Mod ) { assert ( Mod >= 2 ), assert ( Mod % 2 == 1 ); assert (( Mod >> ( B0 - 2 )) == 0 ); n = nr = Mod , rs = - static_cast < U1 > ( n ) % n ; for ( u32 i = 0 ; i < __lg ( B0 ); i ++ ) { nr *= 2 - n * nr ; } np = Reduce ( static_cast < U0 > ( 1 ), rs ); } constexpr U0 Reduce ( const U0 & x ) const noexcept { const U0 q = x * nr ; const U0 m = ( static_cast < U1 > ( q ) * n ) >> B0 ; return n - m ; } constexpr U0 Reduce ( const U0 & x , const U0 & y ) const noexcept { const U1 t = static_cast < U1 > ( x ) * y ; const U0 c = t , d = t >> B0 ; const U0 q = c * nr ; const U0 m = ( static_cast < U1 > ( q ) * n ) >> B0 ; return d + n - m ; } constexpr U0 Reduce ( const U0 & x , const U0 & y , const U0 & z ) const noexcept { const U1 t = static_cast < U1 > ( x ) * y ; const U0 c = t , d = t >> B0 ; const U0 q = c * nr ; const U0 m = ( static_cast < U1 > ( q ) * n ) >> B0 ; return z + d + n - m ; } constexpr U0 val ( const U0 & x ) const noexcept { const u64 t = Reduce ( x ); return ( t == n ) ? static_cast < U0 > ( 0 ) : t ; } constexpr U0 zero () const noexcept { return static_cast < U0 > ( 0 ); } constexpr U0 one () const noexcept { return np ; } constexpr U0 raw ( const U0 & x ) const noexcept { return Reduce ( x , rs ); } template < class U > requires std :: unsigned_integral < U > constexpr U0 trans ( const U & x ) const noexcept { if ( __builtin_expect ( x < n , 1 )) { return raw ( x ); } return Reduce ( x % n , rs ); } template < class S > requires std :: signed_integral < S > constexpr U0 trans ( S x ) const noexcept { if ( __builtin_expect ( 0 <= x && x < static_cast < S > ( n ), 1 )) { return Raw ( x ); } if (( x %= static_cast < S > ( n )) < 0 ) { ( x += static_cast < S > ( n )) %= static_cast < S > ( n ); } return Reduce ( x , rs ); } constexpr U0 neg ( const U0 & x ) const noexcept { return ( x != 0 ) ? ( 2 * n - x ) : x ; } constexpr U0 inc ( const U0 & x ) const noexcept { return add ( x , np ); } constexpr U0 dec ( const U0 & x ) const noexcept { return sub ( x , np ); } constexpr U0 add ( const U0 & x , const U0 & y ) const noexcept { return ( x + y >= 2 * n ) ? ( x + y - 2 * n ) : ( x + y ); } constexpr U0 sub ( const U0 & x , const U0 & y ) const noexcept { return ( x < y ) ? ( x - y + 2 * n ) : ( x - y ); } constexpr U0 mul ( const U0 & x , const U0 & y ) const noexcept { return Reduce ( x , y ); } constexpr U0 mul_add ( const U0 & x , const U0 & y , const U0 & z ) const noexcept { return Reduce ( x , y , z ); } constexpr bool same ( const U0 & x , const U0 & y ) const noexcept { const U0 dif = x - y ; return ( dif == 0 ) || ( dif == n ) || ( dif == - n ); } }; constexpr bool Is_Prime ( u64 x ) noexcept { if ( x <= 1 ) { return false ; } if ( x % 2 == 0 ) { return x == 2 ; } constexpr array < u64 , 10 > Base { 2 , 7 , 61 , 2 , 325 , 9375 , 28178 , 450775 , 9780504 , 1795265022 }; const u32 s = __builtin_ctzll ( x - 1 ); const u64 d = ( x - 1 ) >> s ; const int q = 63 ^ __builtin_clzll ( d ); const Montgomery < u64 , u128 > Mod ( x ); const u32 l = ( x >> 32 ) ? 3 : 0 ; const u32 r = ( x >> 32 ) ? 10 : 3 ; for ( u32 _ = l ; _ < r ; _ ++ ) { u64 base = Base [ _ ]; if ( base % x == 0 ) { continue ; } base = Mod . trans ( base ); u64 a = base ; for ( int i = q - 1 ; ~ i ; i -- ) { a = Mod . mul ( a , a ); if (( d >> i ) & 1 ) { a = Mod . mul ( a , base ); } } if ( Mod . same ( a , Mod . one ())) { continue ; } for ( u32 t = 1 ; t < s && ! Mod . same ( a , x - Mod . one ()); ++ t ) { a = Mod . mul ( a , a ); } if ( ! Mod . same ( a , x - Mod . one ())) { return false ; } } return true ; } u64 Find_Prime_Factor ( const u64 & n ) { if ( n % 2 == 0 ) { return 2ULL ; } const Montgomery < u64 , u128 > Mod ( n ); const u64 C1 = 1 , C2 = 2 , M = 512 ; u64 Z1 = 1 , Z2 = 2 , ans = 0 ; auto find = [ & ]() { u64 z1 = Z1 , z2 = Z2 ; for ( u64 k = M ; ; k *= 2 ) { const u64 x1 = z1 + n , x2 = z2 + n ; for ( u64 j = 0 ; j < k ; j += M ) { const u64 y1 = z1 , y2 = z2 ; u64 q1 = 1 , q2 = 2 ; z1 = Mod . mul_add ( z1 , z1 , C1 ), z2 = Mod . mul_add ( z2 , z2 , C2 ); for ( u64 i = 0 ; i < M ; ++ i ) { u64 t1 = x1 - z1 , t2 = x2 - z2 ; z1 = Mod . mul_add ( z1 , z1 , C1 ), z2 = Mod . mul_add ( z2 , z2 , C2 ); q1 = Mod . mul ( q1 , t1 ), q2 = Mod . mul ( q2 , t2 ); } q1 = Mod . mul ( q1 , x1 - z1 ), q2 = Mod . mul ( q2 , x2 - z2 ); const u64 q3 = Mod . mul ( q1 , q2 ), g3 = std :: gcd ( n , q3 ); if ( g3 == 1 ) { continue ; } if ( g3 != n ) { ans = g3 ; return ; } const u64 g1 = std :: gcd ( n , q1 ); const u64 g2 = std :: gcd ( n , q2 ); const u64 C = g1 != 1 ? C1 : C2 ; const u64 x = g1 != 1 ? x1 : x2 ; u64 z = g1 != 1 ? y1 : y2 ; u64 g = g1 != 1 ? g1 : g2 ; if ( g == n ) { do { z = Mod . mul_add ( z , z , C ); g = std :: gcd ( n , x - z ); } while ( g == 1 ); } if ( g != n ) { ans = g ; return ; } Z1 += 2 , Z2 += 2 ; return ; } } }; do { find (); } while ( ! ans ); return ans ; } template < bool sorted > vector < pair < u64 , u32 >> Factorize ( u64 n ) { vector < pair < u64 , u32 >> ans ; if ( n % 2 == 0 ) { u32 z = __builtin_ctzll ( n ); ans . push_back ({ 2ULL , z }), n >>= z ; } auto upd = [ & ]( const u64 & x ) { for ( auto & [ p , c ] : ans ) { if ( x == p ) { ++ c ; return ; } } ans . push_back ({ x , 1 }); }; auto DFS = [ & ]( auto && self , const u64 & n ) -> void { if ( Is_Prime ( n )) { return upd ( n ); } u64 d = Find_Prime_Factor ( n ); self ( self , d ), self ( self , n / d ); }; if ( n > 1 ) { DFS ( DFS , n ); } if constexpr ( sorted ) { sort ( ans . begin (), ans . end ()); } return ans ; }","title":"\u8d28\u56e0\u6570\u5206\u89e3"},{"location":"Math/NumberTheory/Factorize/#\u8d28\u56e0\u6570\u5206\u89e3","text":"Is_Prime \u662f Miller-Rabin \u5224\u65ad\u662f\u5426\u662f\u7d20\u6570\uff0c Factorize \u662f Pollard-Rho \u8d28\u56e0\u6570\u5206\u89e3\uff0c\u8fd4\u56de\u4e00\u4e2a vector<pair<u64, u32>> \uff0c first \u662f\u8d28\u56e0\u6570\uff0c second \u662f\u8d28\u56e0\u6570\u5e42\u6b21\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 template < class U0 , class U1 > struct Montgomery { constexpr static unsigned B0 = sizeof ( U0 ) * 8U ; U0 n , nr , rs , np ; constexpr Montgomery ( const U0 & Mod ) { SetMod ( Mod ); } constexpr U0 GetMod () const noexcept { return n ; } constexpr void SetMod ( const U0 & Mod ) { assert ( Mod >= 2 ), assert ( Mod % 2 == 1 ); assert (( Mod >> ( B0 - 2 )) == 0 ); n = nr = Mod , rs = - static_cast < U1 > ( n ) % n ; for ( u32 i = 0 ; i < __lg ( B0 ); i ++ ) { nr *= 2 - n * nr ; } np = Reduce ( static_cast < U0 > ( 1 ), rs ); } constexpr U0 Reduce ( const U0 & x ) const noexcept { const U0 q = x * nr ; const U0 m = ( static_cast < U1 > ( q ) * n ) >> B0 ; return n - m ; } constexpr U0 Reduce ( const U0 & x , const U0 & y ) const noexcept { const U1 t = static_cast < U1 > ( x ) * y ; const U0 c = t , d = t >> B0 ; const U0 q = c * nr ; const U0 m = ( static_cast < U1 > ( q ) * n ) >> B0 ; return d + n - m ; } constexpr U0 Reduce ( const U0 & x , const U0 & y , const U0 & z ) const noexcept { const U1 t = static_cast < U1 > ( x ) * y ; const U0 c = t , d = t >> B0 ; const U0 q = c * nr ; const U0 m = ( static_cast < U1 > ( q ) * n ) >> B0 ; return z + d + n - m ; } constexpr U0 val ( const U0 & x ) const noexcept { const u64 t = Reduce ( x ); return ( t == n ) ? static_cast < U0 > ( 0 ) : t ; } constexpr U0 zero () const noexcept { return static_cast < U0 > ( 0 ); } constexpr U0 one () const noexcept { return np ; } constexpr U0 raw ( const U0 & x ) const noexcept { return Reduce ( x , rs ); } template < class U > requires std :: unsigned_integral < U > constexpr U0 trans ( const U & x ) const noexcept { if ( __builtin_expect ( x < n , 1 )) { return raw ( x ); } return Reduce ( x % n , rs ); } template < class S > requires std :: signed_integral < S > constexpr U0 trans ( S x ) const noexcept { if ( __builtin_expect ( 0 <= x && x < static_cast < S > ( n ), 1 )) { return Raw ( x ); } if (( x %= static_cast < S > ( n )) < 0 ) { ( x += static_cast < S > ( n )) %= static_cast < S > ( n ); } return Reduce ( x , rs ); } constexpr U0 neg ( const U0 & x ) const noexcept { return ( x != 0 ) ? ( 2 * n - x ) : x ; } constexpr U0 inc ( const U0 & x ) const noexcept { return add ( x , np ); } constexpr U0 dec ( const U0 & x ) const noexcept { return sub ( x , np ); } constexpr U0 add ( const U0 & x , const U0 & y ) const noexcept { return ( x + y >= 2 * n ) ? ( x + y - 2 * n ) : ( x + y ); } constexpr U0 sub ( const U0 & x , const U0 & y ) const noexcept { return ( x < y ) ? ( x - y + 2 * n ) : ( x - y ); } constexpr U0 mul ( const U0 & x , const U0 & y ) const noexcept { return Reduce ( x , y ); } constexpr U0 mul_add ( const U0 & x , const U0 & y , const U0 & z ) const noexcept { return Reduce ( x , y , z ); } constexpr bool same ( const U0 & x , const U0 & y ) const noexcept { const U0 dif = x - y ; return ( dif == 0 ) || ( dif == n ) || ( dif == - n ); } }; constexpr bool Is_Prime ( u64 x ) noexcept { if ( x <= 1 ) { return false ; } if ( x % 2 == 0 ) { return x == 2 ; } constexpr array < u64 , 10 > Base { 2 , 7 , 61 , 2 , 325 , 9375 , 28178 , 450775 , 9780504 , 1795265022 }; const u32 s = __builtin_ctzll ( x - 1 ); const u64 d = ( x - 1 ) >> s ; const int q = 63 ^ __builtin_clzll ( d ); const Montgomery < u64 , u128 > Mod ( x ); const u32 l = ( x >> 32 ) ? 3 : 0 ; const u32 r = ( x >> 32 ) ? 10 : 3 ; for ( u32 _ = l ; _ < r ; _ ++ ) { u64 base = Base [ _ ]; if ( base % x == 0 ) { continue ; } base = Mod . trans ( base ); u64 a = base ; for ( int i = q - 1 ; ~ i ; i -- ) { a = Mod . mul ( a , a ); if (( d >> i ) & 1 ) { a = Mod . mul ( a , base ); } } if ( Mod . same ( a , Mod . one ())) { continue ; } for ( u32 t = 1 ; t < s && ! Mod . same ( a , x - Mod . one ()); ++ t ) { a = Mod . mul ( a , a ); } if ( ! Mod . same ( a , x - Mod . one ())) { return false ; } } return true ; } u64 Find_Prime_Factor ( const u64 & n ) { if ( n % 2 == 0 ) { return 2ULL ; } const Montgomery < u64 , u128 > Mod ( n ); const u64 C1 = 1 , C2 = 2 , M = 512 ; u64 Z1 = 1 , Z2 = 2 , ans = 0 ; auto find = [ & ]() { u64 z1 = Z1 , z2 = Z2 ; for ( u64 k = M ; ; k *= 2 ) { const u64 x1 = z1 + n , x2 = z2 + n ; for ( u64 j = 0 ; j < k ; j += M ) { const u64 y1 = z1 , y2 = z2 ; u64 q1 = 1 , q2 = 2 ; z1 = Mod . mul_add ( z1 , z1 , C1 ), z2 = Mod . mul_add ( z2 , z2 , C2 ); for ( u64 i = 0 ; i < M ; ++ i ) { u64 t1 = x1 - z1 , t2 = x2 - z2 ; z1 = Mod . mul_add ( z1 , z1 , C1 ), z2 = Mod . mul_add ( z2 , z2 , C2 ); q1 = Mod . mul ( q1 , t1 ), q2 = Mod . mul ( q2 , t2 ); } q1 = Mod . mul ( q1 , x1 - z1 ), q2 = Mod . mul ( q2 , x2 - z2 ); const u64 q3 = Mod . mul ( q1 , q2 ), g3 = std :: gcd ( n , q3 ); if ( g3 == 1 ) { continue ; } if ( g3 != n ) { ans = g3 ; return ; } const u64 g1 = std :: gcd ( n , q1 ); const u64 g2 = std :: gcd ( n , q2 ); const u64 C = g1 != 1 ? C1 : C2 ; const u64 x = g1 != 1 ? x1 : x2 ; u64 z = g1 != 1 ? y1 : y2 ; u64 g = g1 != 1 ? g1 : g2 ; if ( g == n ) { do { z = Mod . mul_add ( z , z , C ); g = std :: gcd ( n , x - z ); } while ( g == 1 ); } if ( g != n ) { ans = g ; return ; } Z1 += 2 , Z2 += 2 ; return ; } } }; do { find (); } while ( ! ans ); return ans ; } template < bool sorted > vector < pair < u64 , u32 >> Factorize ( u64 n ) { vector < pair < u64 , u32 >> ans ; if ( n % 2 == 0 ) { u32 z = __builtin_ctzll ( n ); ans . push_back ({ 2ULL , z }), n >>= z ; } auto upd = [ & ]( const u64 & x ) { for ( auto & [ p , c ] : ans ) { if ( x == p ) { ++ c ; return ; } } ans . push_back ({ x , 1 }); }; auto DFS = [ & ]( auto && self , const u64 & n ) -> void { if ( Is_Prime ( n )) { return upd ( n ); } u64 d = Find_Prime_Factor ( n ); self ( self , d ), self ( self , n / d ); }; if ( n > 1 ) { DFS ( DFS , n ); } if constexpr ( sorted ) { sort ( ans . begin (), ans . end ()); } return ans ; }","title":"\u8d28\u56e0\u6570\u5206\u89e3"},{"location":"Math/NumberTheory/PrimitiveRoot/","text":"\u6c42\u539f\u6839\uff0c\u9700\u524d\u7f6e Factorize() \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 u64 primitive_root ( u64 P ) { if ( P == 2 ) return 1 ; if ( P == 167772161 ) return 3 ; if ( P == 469762049 ) return 3 ; if ( P == 754974721 ) return 11 ; if ( P == 998244353 ) return 3 ; auto f = Factorize < false > ( P - 1 ); const Montgomery < u64 , u128 > Mod ( P ); u64 g = Mod . raw ( 2 ); while ( true ) { if ([ & ]() { for ( auto [ p , e ] : f ) { if ( Mod . same ( Mod . pow ( g , ( P - 1 ) / p ), Mod . one ())) { return false ; } } return true ; }()) return Mod . val ( g ); g = Mod . inc ( g ); } }","title":"\u539f\u6839"},{"location":"Math/NumberTheory/Sieve/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 vector < int > minp , primes , lowp ; void Sieve ( int n ) { minp . assign ( n , 0 ); lowp . assign ( n , 0 ); primes . clear (); for ( int i = 2 ; i < n ; i ++ ) { if ( minp [ i ] == 0 ) { minp [ i ] = i , lowp [ i ] = i ; primes . emplace_back ( i ); } for ( auto p : primes ) { if ( i * p >= n ) { break ; } minp [ i * p ] = p ; if ( p == minp [ i ]) { lowp [ i * p ] = lowp [ i ] * p ; break ; } lowp [ i * p ] = p ; } } } bool is_prime ( int n ) { return minp [ n ] == n ; }","title":"\u7ebf\u6027\u7b5b"},{"location":"Math/Polynomial/Interpolation/","text":"\u8fde\u7eed\u70b9\u503c \u62c9\u683c\u6717\u65e5\u63d2\u503c\u6c42\u591a\u9879\u5f0f\u7cfb\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // x = 0, 1, 2, ..., n - 1 vector < Z > Lagrange ( vector < Z > y ) { if ( y . empty ()) return y ; const int n = ( int ) y . size (); vector < Z > f ( n + 1 ), a ( n ), coef , g ( n ); for ( int i = 0 ; i < n ; i ++ ) { Z res = y [ i ] * comb . ifac ( i ) * comb . ifac ( n - i - 1 ); (( n - i - 1 ) & 1 ) ? a [ i ] = - res : a [ i ] = res ; } f [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { f [ i + 1 ] = 0 ; for ( int j = i + 1 ; j ; j -- ) f [ j ] = f [ j - 1 ] - i * f [ j ]; f [ 0 ] = - f [ 0 ] * i ; } coef = f , coef . erase ( coef . begin ()); for ( auto & x : coef ) x *= a [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { g [ 0 ] = - comb . inv ( i ) * f [ 0 ]; for ( int j = 1 ; j < n ; j ++ ) g [ j ] = comb . inv ( i ) * ( g [ j - 1 ] - f [ j ]); for ( int j = 0 ; j < n ; j ++ ) coef [ j ] += a [ i ] * g [ j ]; } return coef ; } \u6c42\u70b9\u503c\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int n , k , ans , x [ 2001 ], y [ 2001 ]; inline void mian () { read ( n , k ); for ( int i = 1 ; i <= n ; ++ i ) read ( x [ i ], y [ i ]); for ( int i = 1 ; i <= n ; ++ i ) { int up = y [ i ], down = 1 ; for ( int j = 1 ; j <= n ; ++ j ) { if ( i == j ) continue ; Mmul ( up , k - x [ j ]), Mmul ( down , x [ i ] - x [ j ]); } Madd ( ans , Cmul ( up , power ( down , MOD -2 ))); } write ( ans ); }","title":"\u62c9\u683c\u6717\u65e5\u63d2\u503c"},{"location":"Math/Polynomial/Interpolation/#\u8fde\u7eed\u70b9\u503c","text":"","title":"\u8fde\u7eed\u70b9\u503c"},{"location":"Math/Polynomial/Interpolation/#\u62c9\u683c\u6717\u65e5\u63d2\u503c\u6c42\u591a\u9879\u5f0f\u7cfb\u6570","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // x = 0, 1, 2, ..., n - 1 vector < Z > Lagrange ( vector < Z > y ) { if ( y . empty ()) return y ; const int n = ( int ) y . size (); vector < Z > f ( n + 1 ), a ( n ), coef , g ( n ); for ( int i = 0 ; i < n ; i ++ ) { Z res = y [ i ] * comb . ifac ( i ) * comb . ifac ( n - i - 1 ); (( n - i - 1 ) & 1 ) ? a [ i ] = - res : a [ i ] = res ; } f [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { f [ i + 1 ] = 0 ; for ( int j = i + 1 ; j ; j -- ) f [ j ] = f [ j - 1 ] - i * f [ j ]; f [ 0 ] = - f [ 0 ] * i ; } coef = f , coef . erase ( coef . begin ()); for ( auto & x : coef ) x *= a [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { g [ 0 ] = - comb . inv ( i ) * f [ 0 ]; for ( int j = 1 ; j < n ; j ++ ) g [ j ] = comb . inv ( i ) * ( g [ j - 1 ] - f [ j ]); for ( int j = 0 ; j < n ; j ++ ) coef [ j ] += a [ i ] * g [ j ]; } return coef ; } \u6c42\u70b9\u503c\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int n , k , ans , x [ 2001 ], y [ 2001 ]; inline void mian () { read ( n , k ); for ( int i = 1 ; i <= n ; ++ i ) read ( x [ i ], y [ i ]); for ( int i = 1 ; i <= n ; ++ i ) { int up = y [ i ], down = 1 ; for ( int j = 1 ; j <= n ; ++ j ) { if ( i == j ) continue ; Mmul ( up , k - x [ j ]), Mmul ( down , x [ i ] - x [ j ]); } Madd ( ans , Cmul ( up , power ( down , MOD -2 ))); } write ( ans ); }","title":"\u62c9\u683c\u6717\u65e5\u63d2\u503c\u6c42\u591a\u9879\u5f0f\u7cfb\u6570"},{"location":"Math/Polynomial/Poly/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 namespace Polynomial { using u64 = unsigned long long ; constexpr unsigned Mod = Z :: GetMod (); constexpr size_t logord = __builtin_ctz ( Mod - 1 ); constexpr Z g = 3 , zeta = g . Pow (( Mod - 1 ) >> logord ), inv_zeta = zeta . inv (); vector < Z > _root { Z :: raw ( 1 )}, _inv_root { Z :: raw ( 1 )}; Z * root ( const size_t & n ) { const size_t sz = _root . size (); if ( sz < n ) { _root . resize ( n ); for ( size_t i = __builtin_ctz ( sz ); static_cast < size_t > ( 1 ) << i < n ; i ++ ) { const size_t j = 1 << i ; _root [ j ] = zeta . Pow ( 1 << ( logord - i - 2 )); for ( size_t k = j + 1 ; k < j * 2 ; k ++ ) _root [ k ] = _root [ k - j ] * _root [ j ]; } } return _root . data (); } Z * inv_root ( const size_t & n ) { const size_t sz = _inv_root . size (); if ( sz < n ) { _inv_root . resize ( n ); for ( size_t i = __builtin_ctz ( sz ); static_cast < size_t > ( 1 ) << i < n ; i ++ ) { const size_t j = 1 << i ; _inv_root [ j ] = inv_zeta . Pow ( 1 << ( logord - i - 2 )); for ( size_t k = j + 1 ; k < j * 2 ; k ++ ) _inv_root [ k ] = _inv_root [ k - j ] * _inv_root [ j ]; } } return _inv_root . data (); } void DFT ( vector < Z > & a ) { const size_t n = a . size (); static vector < u64 > b ; b . resize ( n ), b [ 0 ] = 0 ; for ( size_t j = 0 , k = n >> 1 ; j < k ; j ++ ) { u64 u = ( u64 ) a [ j ], v = ( u64 ) a [ j | k ]; b [ j ] = u + v , b [ j | k ] = u + Mod - v ; } Z * rt = root ( n >> 1 ); for ( size_t k = n >> 2 ; k >= 1 ; k >>= 1 ) { for ( size_t j = 0 ; j < k ; j ++ ) { u64 u = b [ j ], v = b [ j | k ] % Mod ; b [ j ] = u + v , b [ j | k ] = u + Mod - v ; } for ( size_t i = k << 1 , m = 1 ; i < n ; i += k << 1 , m ++ ) for ( size_t j = 0 ; j < k ; j ++ ) { u64 u = b [ i | j ], v = b [ i | j | k ] * ( u64 ) rt [ m ] % Mod ; b [ i | j ] = u + v , b [ i | j | k ] = u + Mod - v ; } } for ( size_t i = 0 ; i < n ; i ++ ) a [ i ] = b [ i ]; return ; } void IDFT ( vector < Z > & a ) { const size_t n = a . size (); Z * rt = inv_root ( n / 2 ); for ( size_t k = 1 ; k << 1 < n ; k <<= 1 ) { for ( size_t j = 0 ; j < k ; j ++ ) { Z u = a [ j ], v = a [ j | k ]; a [ j ] = u + v , a [ j | k ] = u - v ; } for ( size_t i = k << 1 , m = 1 ; i < n ; i += k << 1 , m ++ ) for ( size_t j = 0 ; j < k ; j ++ ) { Z u = a [ i | j ], v = a [ i | j | k ]; a [ i | j ] = u + v , a [ i | j | k ] = ( u - v ) * rt [ m ]; } } Z inv = Z :: raw ( Mod - Mod / n ); for ( size_t j = 0 , k = n >> 1 ; j < k ; j ++ ) { Z u = a [ j ] * inv , v = a [ j | k ] * inv ; a [ j ] = u + v , a [ j | k ] = u - v ; } return ; } struct Poly : public vector < Z > { Poly () : vector < Z > () { return ; } explicit Poly ( int n ) : vector < Z > ( n ) { return ; } explicit Poly ( const vector < Z > & a ) : vector < Z > ( a ) { return ; } explicit Poly ( const initializer_list < Z > & a ) : vector < Z > ( a ) { return ; } template < class _InputIterator , class = _RequireInputIter < _InputIterator >> explicit constexpr Poly ( _InputIterator __first , _InputIterator __last ) : vector < Z > ( __first , __last ) { return ; } template < class F > explicit constexpr Poly ( int n , F f ) : vector < Z > ( n ) { for ( int i = 0 ; i < n ; i ++ ) ( * this )[ i ] = f ( i ); return ; } Poly Shift ( const int & k ) const { if ( k >= 0 ) { auto ret = * this ; ret . insert ( ret . begin (), k , Z ( 0 )); return ret ; } else return ( int ) this -> size () <= - k ? Poly () : Poly ( this -> begin () - k , this -> end ()); } Poly Trunc ( const size_t & k ) const { Poly f = * this ; f . resize ( k ); return f ; } friend Poly operator - ( Poly rhs ) { const size_t n = rhs . size (); for ( size_t i = 0 ; i < n ; i ++ ) rhs [ i ] = - rhs [ i ]; return rhs ; } friend Poly operator + ( const Poly & rhs ) { return rhs ; } Poly & operator += ( const Poly & rhs ) { const size_t n = size (), m = rhs . size (); this -> resize ( std :: max ( n , m )); for ( size_t i = 0 ; i < m ; i ++ ) ( * this )[ i ] += rhs [ i ]; return * this ; } Poly & operator += ( const Z & rhs ) { if ( __builtin_expect ( empty (), 0 )) return ( * this ) = Poly { rhs }; return ( * this )[ 0 ] += rhs , * this ; } Poly & operator -= ( const Poly & rhs ) { const size_t n = size (), m = rhs . size (); this -> resize ( std :: max ( n , m )); for ( size_t i = 0 ; i < m ; i ++ ) ( * this )[ i ] -= rhs [ i ]; return * this ; } Poly & operator -= ( const Z & rhs ) { if ( __builtin_expect ( empty (), 0 )) return ( * this ) = Poly { - rhs }; return ( * this )[ 0 ] -= rhs , * this ; } Poly & operator *= ( Poly rhs ) { if ( __builtin_expect ( ! size () || ! rhs . size (), 0 )) return ( * this ) = Poly (); if ( size () < rhs . size ()) std :: swap ( * this , rhs ); const size_t n1 = size (), n2 = rhs . size (); const size_t m = n1 + n2 - 1 ; if ( n2 < static_cast < size_t > ( 1 ) << 7 ) { Poly ret ( m ); for ( size_t i = 0 ; i < n1 ; i ++ ) for ( size_t j = 0 ; j < n2 ; j ++ ) ret [ i + j ] += ( * this )[ i ] * rhs [ j ]; return * this = move ( ret ); } size_t n = 1 ; while ( n <= m ) n <<= 1 ; resize ( n ), DFT ( * this ), rhs . resize ( n ), DFT ( rhs ); for ( size_t i = 0 ; i < n ; i ++ ) ( * this )[ i ] *= rhs [ i ]; IDFT ( * this ), resize ( m ); return * this ; } Poly & operator *= ( const Z & rhs ) { const size_t n = size (); for ( size_t i = 0 ; i < n ; i ++ ) ( * this )[ i ] *= rhs ; return * this ; } Poly & operator /= ( const Poly & rhs ) { const size_t n = size (), m = rhs . size (); if ( __builtin_expect ( m > n , 0 )) return ( * this ) = Poly (); auto RG = rhs ; reverse ( begin (), end ()), resize ( n + 1 - m ); reverse ( RG . begin (), RG . end ()), RG . resize ( n + 1 - m ); ( * this ) *= Inv ( RG , n + 1 - m ), ( * this ) = Trunc ( n + 1 - m ); reverse ( begin (), end ()); return * this ; } Poly & operator /= ( const Z & rhs ) { return ( * this ) *= rhs . inv (); } friend Poly operator + ( Poly lhs , const Poly & rhs ) { return lhs += rhs ; } friend Poly operator + ( Poly lhs , const Z & rhs ) { return lhs += rhs ; } friend Poly operator + ( const Z & lhs , Poly rhs ) { return rhs += lhs ; } friend Poly operator - ( Poly lhs , const Poly & rhs ) { return lhs -= rhs ; } friend Poly operator - ( Poly lhs , const Z & rhs ) { return lhs -= rhs ; } friend Poly operator - ( const Z & lhs , Poly rhs ) { return - ( rhs -= lhs ); } friend Poly operator * ( Poly lhs , const Poly & rhs ) { return lhs *= rhs ; } friend Poly operator * ( Poly lhs , const Z & rhs ) { return lhs *= rhs ; } friend Poly operator * ( const Z & lhs , Poly rhs ) { return rhs *= lhs ; } friend Poly operator / ( Poly lhs , const Poly & rhs ) { return lhs /= rhs ; } friend Poly operator / ( Poly lhs , const Z & rhs ) { return lhs /= rhs ; } friend Poly Deriv ( const Poly & f ) { const size_t n = f . size (); if ( n == 0 ) return f ; Poly g ( n - 1 ); for ( size_t i = 0 ; i + 1 < n ; i ++ ) g [ i ] = ( i + 1 ) * f [ i + 1 ]; return g ; } friend Poly Integr ( const Poly & f ) { const size_t n = f . size (); Poly g ( n + 1 ); for ( size_t i = 0 ; i < n ; i ++ ) g [ i + 1 ] = f [ i ] * comb . inv ( i + 1 ); return g ; } friend Poly Inv ( const Poly & f , const int & lim ) { assert ( f . size () && f [ 0 ]); Poly g { f [ 0 ]. inv ()}; int k = 1 ; while ( k < lim ) { g . resize ( k <<= 1 ); auto F = f . Trunc ( k ), G = g ; DFT ( F ), DFT ( G ); for ( int i = 0 ; i < k ; i ++ ) F [ i ] = F [ i ] * G [ i ]; IDFT ( F ), -- F [ 0 ]; for ( int i = 0 ; i < k / 2 ; i ++ ) F [ i ] = 0 ; DFT ( F ); for ( int i = 0 ; i < k ; i ++ ) F [ i ] *= G [ i ]; IDFT ( F ); for ( int i = k / 2 ; i < k ; i ++ ) g [ i ] -= F [ i ]; } return g . Trunc ( lim ); } friend pair < Poly , Poly > Div ( const Poly & f , const Poly & g ) { const size_t m = g . size (); assert ( m != 0 ); auto Q = f / g , R = ( f - g * Q ). Trunc ( m - 1 ); return { Q , R }; } friend Poly Div ( const Poly & h , const Poly & f , const size_t & lim ) { if ( __builtin_expect ( lim == 0 , 0 )) return Poly (); if ( __builtin_expect ( h . empty (), 0 )) return Poly ( lim ); assert ( f . size () && f [ 0 ]); size_t k = 1 ; Poly g { f [ 0 ]. inv ()}, q { g [ 0 ] * h [ 0 ]}, F , G , H , Q ; while ( k < lim ) { q . resize ( k <<= 1 ); DFT ( F = move ( f . Trunc ( k ))), DFT ( Q = q ), H = move ( h . Trunc ( k )); for ( size_t i = 0 ; i < k ; i ++ ) F [ i ] *= Q [ i ]; IDFT ( F ); for ( size_t i = 0 ; i < k / 2 ; i ++ ) F [ i ] = Z :: raw ( 0 ); for ( size_t i = k / 2 ; i < k ; i ++ ) F [ i ] -= H [ i ]; DFT ( F ), g . resize ( k ), DFT ( G = g ); for ( size_t i = 0 ; i < k ; i ++ ) F [ i ] *= G [ i ]; IDFT ( F ); for ( size_t i = k / 2 ; i < k ; i ++ ) q [ i ] -= F [ i ]; if ( k < lim ) { g . resize ( k ); DFT ( F = f . Trunc ( k )); for ( size_t i = 0 ; i < k ; i ++ ) F [ i ] = F [ i ] * G [ i ]; IDFT ( F ), -- F [ 0 ]; for ( size_t i = 0 ; i < k / 2 ; i ++ ) F [ i ] = Z :: raw ( 0 ); DFT ( F ); for ( size_t i = 0 ; i < k ; i ++ ) F [ i ] *= G [ i ]; IDFT ( F ); for ( size_t i = k / 2 ; i < k ; i ++ ) g [ i ] -= F [ i ]; } } return q . Trunc ( lim ); } friend Poly Log ( const Poly & f , const size_t & lim ) { return Integr ( Div ( Deriv ( f ), f , lim )). Trunc ( lim ); } friend Poly Sqrt ( const Poly & f , const size_t & lim ) { if ( __builtin_expect ( f . empty (), 0 )) return Poly ( lim ); assert ( f [ 0 ] == 1 ); size_t k = 1 ; Poly g { 1 }, h { 1 }, F { 1 }, G , H ; while ( k < lim ) { g . resize ( k <<= 1 ); G = F , F = f . Trunc ( k ), H = h ; for ( size_t i = 0 ; i < k / 2 ; i ++ ) G [ i ] *= G [ i ]; IDFT ( G ); for ( size_t i = 0 ; i < k / 2 ; i ++ ) G [ i ] -= F [ i ] + F [ i + k / 2 ]; G . resize ( k ), H . resize ( k ), DFT ( G ), DFT ( H ); for ( size_t i = 0 ; i < k ; i ++ ) G [ i ] *= H [ i ]; IDFT ( G ); for ( size_t i = 0 ; i < k / 2 ; i ++ ) g [ i + k / 2 ] -= G [ i ]. div_2 (); if ( k < lim ) { h . resize ( k ), DFT ( G = g ), F = G ; for ( size_t i = 0 ; i < k ; i ++ ) G [ i ] = G [ i ] * H [ i ]; IDFT ( G ), -- G [ 0 ]; for ( size_t i = 0 ; i < k / 2 ; i ++ ) G [ i ] = Z :: raw ( 0 ); DFT ( G ); for ( size_t i = 0 ; i < k ; i ++ ) G [ i ] *= H [ i ]; IDFT ( G ); for ( size_t i = k / 2 ; i < k ; i ++ ) h [ i ] -= G [ i ]; } } return g . Trunc ( lim ); } friend Poly Exp ( const Poly & f , const size_t & lim ) { if ( __builtin_expect ( f . empty (), 0 )) { if ( __builtin_expect ( lim == 0 , 0 )) return Poly (); Poly ret ( lim ); ret [ 0 ] = Z :: raw ( 1 ); return ret ; } assert ( f [ 0 ] == 0 ); size_t k = 1 ; Poly g { 1 }, h { 1 }, F { 1 }, dF , G , dG , H ; while ( k < lim ) { G = F , dG = move ( Deriv ( g ). Trunc ( k )); dF = move ( Deriv ( f . Trunc ( k )). Trunc ( k )), DFT ( F = dF ); for ( size_t i = 0 ; i < k ; i ++ ) G [ i ] *= F [ i ]; IDFT ( G ), g . resize ( k <<= 1 ); for ( size_t i = 0 ; i < k / 2 ; i ++ ) G [ i ] = dG [ i ] - G [ i ]; G . insert ( G . begin (), G . back ()), G . back () = Z :: raw ( 0 ); G . resize ( k ), DFT ( G ), h . resize ( k ), H = h , DFT ( H ); for ( size_t i = 0 ; i < k ; i ++ ) G [ i ] *= H [ i ]; IDFT ( G ), G = G . Shift ( k / 2 - 1 ), G . resize ( k - 1 ); G = Integr ( G + dF ) - f . Trunc ( k ); DFT ( G ), H = move ( g . Trunc ( k )), DFT ( H ); for ( size_t i = 0 ; i < k ; i ++ ) G [ i ] *= H [ i ]; IDFT ( G ); for ( size_t i = k / 2 ; i < k ; i ++ ) g [ i ] -= G [ i ]; if ( k < lim ) { h . resize ( k ); DFT ( G = g ), DFT ( H = h ), F = G ; for ( size_t i = 0 ; i < k ; i ++ ) G [ i ] = G [ i ] * H [ i ]; IDFT ( G ), -- G [ 0 ]; for ( size_t i = 0 ; i < k / 2 ; i ++ ) G [ i ] = Z :: raw ( 0 ); DFT ( G ); for ( size_t i = 0 ; i < k ; i ++ ) G [ i ] *= H [ i ]; IDFT ( G ); for ( size_t i = k / 2 ; i < k ; i ++ ) h [ i ] -= G [ i ]; } } return g . Trunc ( lim ); } friend Poly Pow ( const Poly & f , const u64 & k , const size_t & lim ) { size_t i = 0 ; while ( i < f . size () && ! f [ i ]) i ++ ; if ( i == f . size () || i * k >= lim ) return Poly ( lim ); Z v = f [ i ]; Poly g = f . Shift ( - i ) * v . inv (); return Exp ( Log ( move ( g ), lim - i * k ) * k , lim - i * k ). Shift ( i * k ) * v . Pow ( k ); } friend Poly Pow ( const Poly & f , const u64 & k1 , const u64 & k2 , const size_t & lim ) { size_t i = 0 ; while ( i < f . size () && ! f [ i ]) i ++ ; if ( i == f . size () || i * k1 >= lim ) return Poly ( lim ); Z v = f [ i ]; Poly g = f . Shift ( - i ) * v . inv (); return Exp ( Log ( move ( g ), lim - i * k1 ) * k1 , lim - i * k1 ). Shift ( i * k1 ) * v . Pow ( k2 ); } }; } using Polynomial :: DFT ; using Polynomial :: IDFT ; using Polynomial :: Poly ; Poly Berlekamp_Massey ( const Poly & a ) { Poly c , oldc ; int f = - 1 ; for ( int i = 0 ; i < ( int ) a . size (); i ++ ) { Z delta = a [ i ]; for ( int j = 0 ; j < ( int ) c . size (); j ++ ) delta -= c [ j ] * a [ i - j - 1 ]; if ( ! delta ) continue ; if ( !~ f ) { c . resize ( i + 1 ), f = i ; continue ; } Poly d = oldc ; Z df = 0 ; d *= - 1 , d . insert ( d . begin (), 1 ); for ( int j = 0 ; j < ( int ) d . size (); j ++ ) df += d [ j ] * a [ f - j ]; ( d *= delta / df ). insert ( d . begin (), i - f - 1 , Z ( 0 )); auto tmp = c ; c += d ; if ( i - tmp . size () > f - oldc . size ()) oldc = tmp , f = i ; } c *= - 1 , c . insert ( c . begin (), 1 ); return c ; } Z Linear_Recurrence ( Poly F , Poly G , i64 n ) { Poly P , Q ; const int m = G . size (); while ( n ) { Q = G ; for ( int i = 1 ; i < m ; i += 2 ) Q [ i ] = - Q [ i ]; P = F * Q , Q = G * Q ; for ( int i = 0 ; i < m ; i ++ ) G [ i ] = Q [ i << 1 ]; for ( int i = 0 ; i + 1 < m ; i ++ ) F [ i ] = P [ i << 1 | ( n & 1 )]; n >>= 1 ; } return F [ 0 ] / G [ 0 ]; }","title":"\u591a\u9879\u5f0f"},{"location":"Math/Polynomial/SetPowerSeries/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 template < const unsigned short N = 21 > struct SetPowerSeries : public vector < Z > { private : static constexpr void Ranked_Zeta ( const int & n , const Z * f , Z ( * F )[ N + 1 ]) { for ( int S = 0 ; S < 1 << n ; S ++ ) fill ( F [ S ], F [ S ] + n + 1 , 0 ), F [ S ][ __builtin_popcount ( S )] = f [ S ]; for ( int i = 1 ; i < 1 << n ; i <<= 1 ) for ( int j = 0 ; j < 1 << n ; j += i << 1 ) for ( int S = j ; S < j + i ; S ++ ) for ( int k = 0 ; k <= n ; k ++ ) F [ S | i ][ k ] += F [ S ][ k ]; return ; } static constexpr void Ranked_Mobius ( const int & n , Z ( * F )[ N + 1 ], Z * f ) { for ( int i = 1 ; i < 1 << n ; i <<= 1 ) for ( int j = 0 ; j < 1 << n ; j += i << 1 ) for ( int S = j ; S < j + i ; S ++ ) for ( int k = 0 ; k <= n ; k ++ ) F [ S | i ][ k ] -= F [ S ][ k ]; for ( int S = 0 ; S < 1 << n ; S ++ ) f [ S ] = F [ S ][ __builtin_popcount ( S )]; return ; } static constexpr void Convolution_Naive ( const int & n , const Z * f , const Z * g , Z * ret ) { for ( int S = 0 , T ; S < 1 << n ; S ++ ) for ( ret [ T = S ] = f [ S ] * g [ 0 ]; T ; ( -- T ) &= S ) ret [ S ] += f [ S ^ T ] * g [ T ]; return ; } static void Convolution_FWT ( const int & n , const Z * f , const Z * g , Z * ret ) { static Z F [ 1 << N | 32 ][ N + 1 ], G [ 1 << N | 32 ][ N + 1 ]; Ranked_Zeta ( n , f , F ), Ranked_Zeta ( n , g , G ); for ( int S = 0 ; S < 1 << n ; S ++ ) { Z x ; for ( int c = __builtin_popcount ( S ), i = min ( 2 * c , n ), j ; i >= c ; F [ S ][ i -- ] = x ) for ( x . x = 0 , j = i - c ; j <= c ; j ++ ) x += F [ S ][ j ] * G [ S ][ i - j ]; } Ranked_Mobius ( n , F , ret ); return ; } static constexpr void Convolution ( const int & n , const Z * f , const Z * g , Z * ret ) { ( n <= 10 ) ? Convolution_Naive ( n , f , g , ret ) : Convolution_FWT ( n , f , g , ret ); return ; } static constexpr void Division_Naive ( const int & n , Z * f , const Z * g ) { for ( int S = 1 ; S < 1 << n ; S ++ ) for ( int T = S ; T ; ( -- T ) &= S ) f [ S ] -= f [ S ^ T ] * g [ T ]; return ; } static void Division_FWT ( const int & n , Z * f , const Z * g ) { static Z F [ 1 << N | 32 ][ N + 1 ], G [ 1 << N | 32 ][ N + 1 ]; Ranked_Zeta ( n , f , F ), Ranked_Zeta ( n , g , G ); for ( int S = 0 ; S < 1 << n ; S ++ ) for ( int c = __builtin_popcount ( S ), i = 0 ; i <= n ; i ++ ) for ( int j = max ( 0 , i - c ); j < i ; j ++ ) F [ S ][ i ] -= F [ S ][ j ] * G [ S ][ i - j ]; Ranked_Mobius ( n , F , f ); return ; } static constexpr void Division ( const int & n , Z * f , const Z * g ) { ( n <= 10 ) ? Division_Naive ( n , f , g ) : Division_FWT ( n , f , g ); return ; } static constexpr void Composite ( int n , const Z * egf , const Z * f , Z * g ) { for ( int i = n ; ~ i ; i -- ) { for ( int j = n - i ; -- j >= 0 ; ) Convolution ( j , g , f + ( 1 << j ), g + ( 1 << j )); g [ 0 ] = egf [ i ]; } return ; } template < class Func = void ( * )( int , Z & ) > static constexpr void Online_Convolution_Naive ( const int & n , Z * f , const Z * g , const Z & ori , const Func & func = []( int , Z & ) {}) { f [ 0 ] = ori ; for ( int S = 1 ; S < 1 << n ; func ( S , f [ S ]), S ++ ) for ( int T = S ; T ; ( -- T ) &= S ) f [ S ] += f [ S ^ T ] * g [ T ]; return ; } template < class Func = void ( * )( int , Z & ) > static void Online_Convolution_FWT ( const int & n , Z * f , const Z * g , const Z & ori , const Func & func = []( int , Z & ) {}) { static Z F [ N + 1 ][ 1 << N | 32 ], G [ 1 << N | 32 ][ N + 1 ]; fill ( F [ 0 ], F [ 0 ] + ( 1 << n ), ori ), Ranked_Zeta ( n , g , G ); fill ( F [ 1 ], F [ 1 ] + ( 1 << n ), Z ( 0 )); for ( int i = 1 ; i < 1 << n ; i <<= 1 ) func ( i , F [ 1 ][ i ] = ori * g [ i ]); for ( int d = 2 ; d <= n ; d ++ ) { fill ( F [ d ], F [ d ] + ( 1 << n ), Z ( 0 )); for ( int i = 1 ; i < 1 << n ; i <<= 1 ) for ( int j = 0 ; j < 1 << n ; j += i << 1 ) for ( int S = j ; S < j + i ; S ++ ) F [ d - 1 ][ S | i ] += F [ d - 1 ][ S ]; for ( int S = 0 ; S < 1 << n ; S ++ ) if ( int c = __builtin_popcount ( S ); c <= d && d <= c * 2 ) for ( int i = d ; i ; i -- ) F [ d ][ S ] += G [ S ][ i ] * F [ d - i ][ S ]; for ( int i = 1 ; i < 1 << n ; i <<= 1 ) for ( int j = 0 ; j < 1 << n ; j += i << 1 ) for ( int S = j ; S < j + i ; S ++ ) F [ d ][ S | i ] -= F [ d ][ S ]; for ( int S = 0 ; S < 1 << n ; S ++ ) if ( __builtin_popcount ( S ) == d ) func ( S , F [ d ][ S ]); else F [ d ][ S ] = 0 ; } for ( int S = 0 ; S < 1 << n ; S ++ ) f [ S ] = F [ __builtin_popcount ( S )][ S ]; return ; } template < class Func = void ( * )( int , Z & ) > static constexpr void Online_Convolution ( const int & n , Z * f , const Z * g , const Z & ori , const Func & func = []( int , Z & ) {}) { ( n <= 11 ) ? Online_Convolution_Naive ( n , f , g , ori , func ) : Online_Convolution_FWT ( n , f , g , ori , func ); return ; } public : constexpr SetPowerSeries () : vector < Z > () {} explicit constexpr SetPowerSeries ( const int n ) : vector < Z > ( n ) {} explicit constexpr SetPowerSeries ( const vector < Z > & a ) : vector < Z > ( a ) {} constexpr SetPowerSeries ( const initializer_list < Z > & a ) : vector < Z > ( a ) {} template < class _InputIterator , class = _RequireInputIter < _InputIterator >> explicit constexpr SetPowerSeries ( _InputIterator __first , _InputIterator __last ) : vector < Z > ( __first , __last ) {} template < class F = Z ( * )( int ) > explicit constexpr SetPowerSeries ( int n , F f ) : vector < Z > ( n ) { for ( int i = 0 ; i < n ; i ++ ) ( * this )[ i ] = f ( i ); } friend constexpr SetPowerSeries Subset_Zeta ( SetPowerSeries f ) { const int n = __lg ( f . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( static_cast < int > ( f . size ()) == 1 << n ); for ( int i = 1 ; i < 1 << n ; i <<= 1 ) for ( int j = 0 ; j < 1 << n ; j += i << 1 ) for ( int S = j ; S < j + i ; S ++ ) f [ S | i ] += f [ S ]; return f ; } friend constexpr SetPowerSeries Subset_Mobius ( SetPowerSeries f ) { const int n = __lg ( f . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( static_cast < int > ( f . size ()) == 1 << n ); for ( int i = 1 ; i < 1 << n ; i <<= 1 ) for ( int j = 0 ; j < 1 << n ; j += i << 1 ) for ( int S = j ; S < j + i ; S ++ ) f [ S | i ] -= f [ S ]; return f ; } friend constexpr SetPowerSeries Supset_Zeta ( SetPowerSeries f ) { const int n = __lg ( f . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( static_cast < int > ( f . size ()) == 1 << n ); for ( int i = 1 ; i < 1 << n ; i <<= 1 ) for ( int j = 0 ; j < 1 << n ; j += i << 1 ) for ( int S = j ; S < j + i ; S ++ ) f [ S ] += f [ S | i ]; return f ; } friend constexpr SetPowerSeries Supset_Mobius ( SetPowerSeries f ) { const int n = __lg ( f . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( static_cast < int > ( f . size ()) == 1 << n ); for ( int i = 1 ; i < 1 << n ; i <<= 1 ) for ( int j = 0 ; j < 1 << n ; j += i << 1 ) for ( int S = j ; S < j + i ; S ++ ) f [ S ] -= f [ S | i ]; return f ; } friend constexpr SetPowerSeries FWT ( SetPowerSeries f ) { const int n = __lg ( f . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( static_cast < int > ( f . size ()) == 1 << n ); for ( int i = 1 ; i < 1 << n ; i <<= 1 ) for ( int j = 0 ; j < 1 << n ; j += i << 1 ) for ( int S = j ; S < j + i ; S ++ ) { Z x = f [ S ], y = f [ S | i ]; f [ S ] = x + y , f [ S | i ] = x - y ; } return f ; } friend constexpr SetPowerSeries IFWT ( SetPowerSeries f ) { constexpr Z inv2 = ( MOD + 1 ) >> 1 ; const int n = __lg ( f . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( static_cast < int > ( f . size ()) == 1 << n ); for ( int i = 1 ; i < 1 << n ; i <<= 1 ) for ( int j = 0 ; j < 1 << n ; j += i << 1 ) for ( int S = j ; S < j + i ; S ++ ) { Z x = f [ S ], y = f [ S | i ]; f [ S ] = inv2 * ( x + y ), f [ S | i ] = inv2 * ( x - y ); } return f ; } friend constexpr SetPowerSeries And_Convolution ( SetPowerSeries f , SetPowerSeries g ) { const int n = __lg ( f . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( static_cast < int > ( f . size ()) == 1 << n ); assert ( static_cast < int > ( g . size ()) == 1 << n ); f = Supset_Zeta ( f ), g = Supset_Zeta ( g ); for ( int S = 0 ; S < 1 << n ; S ++ ) f [ S ] *= g [ S ]; return Supset_Mobius ( f ); } friend constexpr SetPowerSeries Or_Convolution ( SetPowerSeries f , SetPowerSeries g ) { const int n = __lg ( f . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( static_cast < int > ( f . size ()) == 1 << n ); assert ( static_cast < int > ( g . size ()) == 1 << n ); f = Subset_Zeta ( f ), g = Subset_Zeta ( g ); for ( int S = 0 ; S < 1 << n ; S ++ ) f [ S ] *= g [ S ]; return Subset_Mobius ( f ); } friend constexpr SetPowerSeries Xor_Convolution ( SetPowerSeries f , SetPowerSeries g ) { const int n = __lg ( f . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( static_cast < int > ( f . size ()) == 1 << n ); assert ( static_cast < int > ( g . size ()) == 1 << n ); f = FWT ( f ), g = FWT ( g ); for ( int S = 0 ; S < 1 << n ; S ++ ) f [ S ] *= g [ S ]; return IFWT ( f ); } friend constexpr SetPowerSeries Subset_Convolution ( const SetPowerSeries & f , const SetPowerSeries & g ) { const int n = __lg ( f . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( static_cast < int > ( f . size ()) == ( 1 << n )); assert ( static_cast < int > ( g . size ()) == ( 1 << n )); SetPowerSeries ret ( 1 << n ); Convolution ( n , f . data (), g . data (), ret . data ()); return ret ; } friend constexpr SetPowerSeries Subset_Division ( SetPowerSeries f , const SetPowerSeries & g ) { const int n = __lg ( f . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( static_cast < int > ( f . size ()) == ( 1 << n )); assert ( static_cast < int > ( g . size ()) == ( 1 << n )); assert ( g [ 0 ]. x == 1 ); Division ( n , f . data (), g . data ()); return f ; } template < class Func = void ( * )( int , Z & ) > friend constexpr SetPowerSeries Online_Subset_Convolution ( const SetPowerSeries & g , const Z & ori , const Func & func = []( int , Z & ) {}) { const int n = __lg ( g . size ()); assert ( 0 <= n && n <= N ); assert ( static_cast < int > ( g . size ()) == 1 << n ); SetPowerSeries f ( 1 << n ); Online_Convolution ( n , f . data (), g . data (), ori , func ); return f ; } friend constexpr SetPowerSeries Inv ( const SetPowerSeries & f ) { const int n = __lg ( f . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( static_cast < int > ( f . size ()) == 1 << n ); assert ( f [ 0 ]. x == 1 ); SetPowerSeries ret ( 1 << n ); ret [ 0 ] = 1 , Division ( n , ret . data (), f . data ()); return ret ; } friend constexpr SetPowerSeries Exp ( const SetPowerSeries & f ) { const int n = __lg ( f . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( f [ 0 ]. x == 0 ); assert ( static_cast < int > ( f . size ()) == ( 1 << n )); SetPowerSeries g ( 1 << n ); g [ 0 ] = 1 ; for ( int k = 0 ; k < n ; k ++ ) Convolution ( k , g . data (), f . data () + ( 1 << k ), g . data () + ( 1 << k )); return g ; } friend constexpr SetPowerSeries Log ( SetPowerSeries f ) { const int n = __lg ( f . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( static_cast < int > ( f . size ()) == 1 << n ); assert ( f [ 0 ]. x == 1 ); SetPowerSeries g ( 1 << n ); for ( int k = n - 1 ; ~ k ; k -- ) { copy ( f . begin () + ( 1 << k ), f . begin () + ( 1 << ( k + 1 )), g . begin () + ( 1 << k )); Division ( k , g . data () + ( 1 << k ), f . data ()); } return g ; } template < class EGF > friend constexpr SetPowerSeries EGF_Composite ( const EGF & egf , const SetPowerSeries & f ) { const int n = __lg ( f . size ()); assert ( static_cast < int > ( egf . size ()) == n + 1 ); assert ( static_cast < int > ( f . size ()) == 1 << n ); assert ( f [ 0 ]. x == 0 ); SetPowerSeries g ( 1 << n ); Composite ( n , egf . data (), f . data (), g . data ()); return g ; } template < class Poly > friend constexpr SetPowerSeries Poly_Composite ( Poly p , SetPowerSeries f ) { const int n = __lg ( f . size ()), m = static_cast < int > ( p . size ()); assert ( static_cast < int > ( f . size ()) == 1 << n ); if ( ! m ) return SetPowerSeries ( 1 << n ); vector < Z > egf ( n + 1 ); for ( int i = 0 ; i <= n ; i ++ ) { Z x = 0 ; for ( int j = m ; -- j >= 0 ; ) ( x *= f [ 0 ]) += p [ j ]; egf [ i ] = x ; for ( int j = 1 ; j < m ; j ++ ) p [ j - 1 ] = p [ j ] * j ; p [ m - 1 ] = 0 ; } f [ 0 ] = 0 ; return EGF_Composite ( egf , f ); } constexpr SetPowerSeries & operator += ( const SetPowerSeries & rhs ) { const int n = __lg ( rhs . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( static_cast < int > ( this -> size ()) == 1 << n ); for ( int S = 0 ; S < 1 << n ; S ++ ) ( * this )[ S ] += rhs [ S ]; return * this ; } constexpr SetPowerSeries & operator -= ( const SetPowerSeries & rhs ) { const int n = __lg ( rhs . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( static_cast < int > ( this -> size ()) == 1 << n ); for ( int S = 0 ; S < 1 << n ; S ++ ) ( * this )[ S ] -= rhs [ S ]; return * this ; } constexpr SetPowerSeries & operator *= ( const SetPowerSeries & rhs ) { const int n = __lg ( rhs . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( static_cast < int > ( this -> size ()) == 1 << n ); return ( * this ) = Subset_Convolution ( * this , rhs ); } constexpr SetPowerSeries & operator /= ( const SetPowerSeries & rhs ) { const int n = __lg ( rhs . size ()); assert ( 0 <= n ), assert ( n <= N ); assert ( static_cast < int > ( this -> size ()) == 1 << n ); return ( * this ) = Subset_Division ( * this , rhs ); } friend constexpr SetPowerSeries operator + ( SetPowerSeries f , const SetPowerSeries & g ) { return f += g ; } friend constexpr SetPowerSeries operator - ( SetPowerSeries f , const SetPowerSeries & g ) { return f -= g ; } friend constexpr SetPowerSeries operator * ( SetPowerSeries f , const SetPowerSeries & g ) { return f *= g ; } friend constexpr SetPowerSeries operator / ( SetPowerSeries f , const SetPowerSeries & g ) { return f /= g ; } }; using SPS = SetPowerSeries <> ;","title":"\u96c6\u5408\u5e42\u7ea7\u6570"},{"location":"Other/BigNum/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 struct BigNum { private : static constexpr ll lim = 1e8 , mod = 1e16 , lm = 10 , Mod = 167772161 , g = 3 , inv2 = ( Mod + 1 ) >> 1 ; static constexpr int pw10 [] = { 1 , 10 , 100 , 1000 , 10000 , 100000 , 1000000 , 10000000 , 100000000 }; static vector < char > str ; static vector < int > rev ; static vector < ll > w ; i64 Mul ( i64 x , i64 y ) { return x * y % Mod ; } i64 Pow ( i64 a , i64 b ) { i64 ans = 1 ; for (; b ; b >>= 1 , a = Mul ( a , a )) if ( b & 1 ) ans = Mul ( ans , a ); return ans ; } void DFT ( vector < i64 > & a ) { const int n = ( int ) a . size (); if (( int ) rev . size () != n ) { int k = __lg ( n ) - 1 ; rev . resize ( n ); for ( int i = 0 ; i < n ; i ++ ) rev [ i ] = ( rev [ i >> 1 ] >> 1 ) | (( i & 1 ) << k ); } if (( int ) w . size () < n ) { int k = __lg ( w . size ()); w . resize ( n ); while ( 1 << k < n ) { i64 e = Pow ( g , ( Mod - 1 ) >> ( k + 1 )); for ( int i = 1 << ( k - 1 ); i < 1 << k ; i ++ ) w [ i << 1 ] = w [ i ], w [ i << 1 | 1 ] = Mul ( w [ i ], e ); k ++ ; } } for ( int i = 0 ; i < n ; i ++ ) if ( i < rev [ i ]) swap ( a [ i ], a [ rev [ i ]]); for ( int k = 1 ; k < n ; k <<= 1 ) for ( int i = 0 ; i < n ; i += k << 1 ) for ( int j = 0 ; j < k ; j ++ ) { i64 u = a [ i | j ], v = Mul ( a [ i | j | k ], w [ j | k ]); a [ i | j ] = u + v >= Mod ? u + v - Mod : u + v ; a [ i | j | k ] = u - v < 0 ? u - v + Mod : u - v ; } return ; } void IDFT ( vector < i64 > & a ) { const int n = ( int ) a . size (); reverse ( a . begin () + 1 , a . end ()); DFT ( a ); i64 inv = ( 1 - Mod ) / n + Mod ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = Mul ( a [ i ], inv ); return ; } vector < i64 > Convolution ( vector < i64 > f , vector < i64 > g ) { if ( f . size () < g . size ()) std :: swap ( f , g ); const int N = f . size (), M = g . size (); int n = 1 , m = N + M - 1 ; if ( g . size () < 1 << 7 ) { vector < i64 > ret ( m ); for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) ret [ i + j ] += f [ i ] * g [ j ]; return ret ; } while ( n < m ) n <<= 1 ; f . resize ( n ), g . resize ( n ), DFT ( f ), DFT ( g ); for ( int i = 0 ; i < n ; i ++ ) f [ i ] = Mul ( f [ i ], g [ i ]); IDFT ( f ), f . resize ( m ); return f ; } public : bool sign ; vector < i64 > num ; BigNum () : sign ( false ), num ( 1 , 0 ) { return ; } BigNum ( i64 x ) { if ( x < 0 ) sign = true , x = - x ; else sign = false ; do num . emplace_back ( x % lim ), x /= lim ; while ( x ); return ; } void Read () { char ch = getchar (); sign = false , num . clear (), str . clear (); while ( ch < '0' || ch > '9' ) sign ^= ch == '-' , ch = getchar (); while ( '0' <= ch && ch <= '9' ) str . emplace_back ( ch ), ch = getchar (); const int n = ( int ) str . size (); num . resize (( n + 7 ) / 8 ); reverse ( str . begin (), str . end ()); for ( int i = 0 , j = -1 ; i < n ; i ++ ) { if ( i % 8 == 0 ) j ++ ; num [ j ] += pw10 [ i - j * 8 ] * ( str [ i ] - '0' ); } return ; } void Write () { if ( ! ( * this )) { putchar ( '0' ); return ; } if ( sign ) putchar ( '-' ); const int n = num . size (); :: Write ( num [ n - 1 ]); for ( int i = n - 2 ; ~ i ; i -- ) for ( int j = 7 ; ~ j ; j -- ) putchar ( num [ i ] / pw10 [ j ] % 10 + '0' ); return ; } vector < i64 > To_Base_1 () const { const int n = num . size (); vector < i64 > ret ( n << 3 ); for ( int i = 0 ; i < n ; i ++ ) { i64 x = num [ i ]; for ( int j = 0 ; j < 8 ; j ++ ) ret [ i * 8 + j ] = x % lm , x /= lm ; } return ret ; } void To_Base_8 ( vector < i64 > v ) { const int n = v . size (); num . assign (( n + 7 ) >> 3 , 0 ); for ( int i = 0 , j = -1 ; i < n ; i ++ ) { if ( ! ( i & 7 )) j ++ ; num [ j ] += v [ i ] * pw10 [ i - j * 8 ]; } while ( num . size () > 1 && ! num . back ()) num . pop_back (); return ; } explicit operator bool () const { return num . size () != 1 || num [ 0 ]; } int get ( const int & i ) const { int x = i / 8 , y = i % 8 ; return num [ x ] / pw10 [ y ] % 10 ; } BigNum Abs () const { BigNum tmp = * this ; tmp . sign = false ; return tmp ; } BigNum Shift ( int k ) { BigNum tmp = * this ; tmp . num . insert ( tmp . num . begin (), k , 0 ); return tmp ; } friend BigNum operator - ( BigNum x ) { return x . sign ^= 1 , x ; } BigNum & operator += ( const BigNum & oth ) { if ( sign == oth . sign ) { const int m = oth . num . size (), n = max (( int ) num . size (), m ); num . resize ( n , 0 ); for ( int i = 0 ; i < m ; i ++ ) num [ i ] += oth . num [ i ]; for ( int i = 0 ; i + 1 < n ; i ++ ) num [ i + 1 ] += num [ i ] >= lim ? 1 : 0 , num [ i ] = num [ i ] >= lim ? num [ i ] - lim : num [ i ]; if ( num [ n - 1 ] >= lim ) num . emplace_back ( 1 ), num [ n - 1 ] -= lim ; return * this ; } if ( sign ) return ( * this ) = oth - ( - ( * this )); return ( * this ) -= - oth ; } BigNum & operator -= ( const BigNum & oth ) { if ( oth . sign == sign ) { if (( * this ) == oth ) return ( * this ) = BigNum ( 0 ); if (( * this ). Abs () < oth . Abs ()) return ( * this ) = - ( oth - ( * this )); const int n = num . size (), m = oth . num . size (); for ( int i = 0 ; i < m ; i ++ ) num [ i ] -= oth . num [ i ]; for ( int i = 0 ; i + 1 < n ; i ++ ) if ( num [ i ] < 0 ) num [ i ] += lim , num [ i + 1 ] -- ; while ( num . size () > 1 && ! num . back ()) num . pop_back (); return * this ; } if ( sign ) return ( * this ) = - (( - ( * this )) + oth ); return ( * this ) += - oth ; } BigNum & operator *= ( const BigNum & oth ) { if ( ! ( * this )) return * this ; if ( ! oth ) return ( * this ) = oth ; const int n = num . size (), m = oth . num . size (); if (( m < 1 << 7 ) || ( n < 1 << 7 )) { BigNum ans ; ans . sign = sign ^ oth . sign ; ans . num . resize ( n + m , 0 ); for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) { ans . num [ i + j ] += num [ i ] * oth . num [ j ]; if ( ans . num [ i + j ] >= mod ) ans . num [ i + j + 1 ] += lim , ans . num [ i + j ] -= mod ; } for ( int i = 0 ; i + 1 < n + m ; i ++ ) ans . num [ i + 1 ] += ans . num [ i ] / lim , ans . num [ i ] %= lim ; if ( ! ans . num . back ()) ans . num . pop_back (); return ( * this ) = ans ; } BigNum ans ; ans . sign = sign ^ oth . sign ; ans . num = Convolution ( To_Base_1 (), oth . To_Base_1 ()); ans . num . resize (( n + m ) << 3 , 0 ); const int k = ans . num . size (); for ( int i = 0 ; i + 1 < k ; i ++ ) ans . num [ i + 1 ] += ans . num [ i ] / lm , ans . num [ i ] %= lm ; ans . To_Base_8 ( ans . num ); return ( * this ) = ans ; } BigNum & operator /= ( const BigNum & oth ) { if ( ! ( * this )) return * this ; const int n = num . size (), m = oth . num . size (); BigNum ans , x = Abs (), y = oth . Abs (); ans . num . resize ( max ( n - m + 1 , 1 )); for ( int i = max ( n - m , - 1 ); ~ i ; i -- ) { int l = 0 , r = lim - 1 ; while ( l < r ) { int mid = ( l + r + 1 ) >> 1 ; if (( y * mid ). Shift ( i ) <= x ) l = mid ; else r = mid - 1 ; } ans . num [ i ] = l , x -= ( y * l ). Shift ( i ); } while ( ans . num . size () > 1 && ! ans . num . back ()) ans . num . pop_back (); ans . sign = sign ^ oth . sign ; if ( ans . sign && ans * oth != ( * this )) -- ans ; if ( ans . num . size () == 1 && ! ans . num [ 0 ]) ans . sign = false ; return ( * this ) = ans ; } BigNum & operator %= ( const BigNum & oth ) { return ( * this ) = ( * this ) - ( * this ) / oth * oth ; } BigNum & operator *= ( const i64 & oth ) { if ( ! oth ) return ( * this ) = BigNum ( 0 ); for ( auto & x : num ) x *= oth ; for ( int i = 0 ; i + 1 < ( int ) num . size (); i ++ ) num [ i + 1 ] += num [ i ] / lim , num [ i ] %= lim ; while ( num . back () > lim ) { i64 x = num . back () / lim ; num . back () %= lim , num . emplace_back ( x ); } while ( num . size () > 1 && ! num . back ()) num . pop_back (); return * this ; } BigNum & operator /= ( const i64 & _x ) { const int n = num . size (); BigNum tmp = * this ; i64 x = _x ; if ( x < 0 ) sign ^= 1 , x = - x ; for ( int i = n - 1 ; i ; i -- ) num [ i - 1 ] += num [ i ] % x * lim , num [ i ] /= x ; num [ 0 ] /= x ; while ( num . size () > 1 && ! num . back ()) num . pop_back (); if ( sign && ( * this ) * x != tmp ) -- ( * this ); if ( num . size () == 1 && ! num [ 0 ]) sign = false ; return * this ; } BigNum & operator %= ( const i64 & x ) { return ( * this ) = ( * this ) - ( * this ) / x * x ; } friend BigNum operator + ( BigNum x , const BigNum & y ) { return x += y ; } friend BigNum operator - ( BigNum x , const BigNum & y ) { return x -= y ; } friend BigNum operator * ( BigNum x , const BigNum & y ) { return x *= y ; } friend BigNum operator / ( BigNum x , const BigNum & y ) { return x /= y ; } friend BigNum operator % ( BigNum x , const BigNum & y ) { return x %= y ; } friend BigNum operator + ( BigNum x , const i64 & y ) { return x += BigNum ( y ); } friend BigNum operator - ( BigNum x , const i64 & y ) { return x -= BigNum ( y ); } friend BigNum operator * ( BigNum x , const i64 & y ) { return x *= y ; } friend BigNum operator / ( BigNum x , const i64 & y ) { return x /= y ; } friend BigNum operator % ( BigNum x , const i64 & y ) { return x %= y ; } friend BigNum operator + ( i64 x , const BigNum & y ) { return BigNum ( x ) += y ; } friend BigNum operator - ( i64 x , const BigNum & y ) { return BigNum ( x ) -= y ; } friend BigNum operator * ( const i64 & x , BigNum y ) { return y *= x ; } friend BigNum operator / ( i64 x , const BigNum & y ) { return BigNum ( x ) /= y ; } friend BigNum operator % ( i64 x , const BigNum & y ) { return BigNum ( x ) %= y ; } BigNum operator ++ ( int ) { BigNum tmp = * this ; ( * this ) += 1 ; return tmp ; } BigNum operator -- ( int ) { BigNum tmp = * this ; ( * this ) -= 1 ; return tmp ; } friend BigNum & operator ++ ( BigNum & x ) { return x += 1 ; } friend BigNum & operator -- ( BigNum & x ) { return x -= 1 ; } friend bool operator == ( const BigNum & x , const BigNum & y ) { const int n = x . num . size (), m = y . num . size (); if ( x . sign != y . sign || n != m ) return false ; for ( int i = 0 ; i < n ; i ++ ) if ( x . num [ i ] != y . num [ i ]) return false ; return true ; } friend bool operator != ( const BigNum & x , const BigNum & y ) { return ! ( x == y ); } friend bool operator < ( const BigNum & x , const BigNum & y ) { if ( x . sign ^ y . sign ) return x . sign ; if ( x . sign && y . sign ) return x . Abs () > y . Abs (); const int n = x . num . size (), m = y . num . size (); if ( n != m ) return n < m ; for ( int i = n - 1 ; ~ i ; i -- ) if ( x . num [ i ] != y . num [ i ]) return x . num [ i ] < y . num [ i ]; return false ; } friend bool operator > ( const BigNum & x , const BigNum & y ) { if ( x . sign ^ y . sign ) return y . sign ; if ( x . sign && y . sign ) return x . Abs () < y . Abs (); const int n = x . num . size (), m = y . num . size (); if ( n != m ) return n > m ; for ( int i = n - 1 ; ~ i ; i -- ) if ( x . num [ i ] != y . num [ i ]) return x . num [ i ] > y . num [ i ]; return false ; } friend bool operator <= ( const BigNum & x , const BigNum & y ) { return ! ( x > y ); } friend bool operator >= ( const BigNum & x , const BigNum & y ) { return ! ( x < y ); } friend ostream & operator << ( ostream & os , const BigNum & x ) { if ( ! x ) { os << 0 ; return os ; } if ( x . sign ) os << '-' ; const int n = x . num . size (); os << x . num [ n - 1 ]; for ( int i = n - 2 ; ~ i ; i -- ) for ( int j = 7 ; ~ j ; j -- ) os << ( char )( x . num [ i ] / pw10 [ j ] % 10 + '0' ); return os ; } }; vector < char > BigNum :: str ; constexpr int BigNum :: pw10 []; vector < int > BigNum :: rev ; vector < i64 > BigNum :: w { 0 , 1 };","title":"\u9ad8\u7cbe\u5ea6"},{"location":"Other/Rational/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 template < class T > struct Frac { T x , y ; Frac () : x ( 0 ), y ( 1 ) { return ; } Frac ( T _x ) : x ( _x ), y ( 1 ) { return ; } Frac ( T _x , T _y ) : x ( _x ), y ( _y ) { if ( y < 0 ) x = - x , y = - y ; return ; } explicit operator double () const { return 1. * x / y ; } explicit operator bool () const { return x ; } void Reduce () { T g = __gcd ( x , y ); x /= g , y /= g ; return ; } Frac & operator += ( const Frac & oth ) { x = x * oth . y + oth . x * y , y *= oth . y ; return * this ; } Frac & operator -= ( const Frac & oth ) { x = x * oth . y - oth . x * y , y *= oth . y ; return * this ; } Frac & operator *= ( const Frac & oth ) { x *= oth . x , y *= oth . y ; return * this ; } Frac & operator /= ( const Frac & oth ) { x *= oth . y , y *= oth . x ; if ( y < 0 ) x = - x , y = - y ; return * this ; } friend Frac operator + ( Frac x , const Frac & y ) { return x += y ; } friend Frac operator - ( Frac x , const Frac & y ) { return x -= y ; } friend Frac operator * ( Frac x , const Frac & y ) { return x *= y ; } friend Frac operator / ( Frac x , const Frac & y ) { return x /= y ; } friend Frac operator - ( const Frac & x ) { return Frac ( - x . x , x . y ); } friend bool operator == ( const Frac & x , const Frac & y ) { return x . x * y . y == x . y * y . x ; } friend bool operator != ( const Frac & x , const Frac & y ) { return x . x * y . y != x . y * y . x ; } friend bool operator < ( const Frac & x , const Frac & y ) { return x . x * y . y < x . y * y . x ; } friend bool operator > ( const Frac & x , const Frac & y ) { return x . x * y . y > x . y * y . x ; } friend bool operator <= ( const Frac & x , const Frac & y ) { return x . x * y . y <= x . y * y . x ; } friend bool operator >= ( const Frac & x , const Frac & y ) { return x . x * y . y >= x . y * y . x ; } friend ostream & operator << ( ostream & os , Frac x ) { x . Reduce (); if ( x . y == 1 ) return os << x . x ; return os << x . x << '/' << x . y ; } void Write () { Reduce (); if ( y == 1 ) :: Write ( x ); else :: Write ( x , '/' , y ); return ; } };","title":"\u6709\u7406\u6570\u7c7b"},{"location":"Other/YesNo/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void YES ( bool f = true ) { f ? Puts ( \"YES\" ) : Puts ( \"NO\" ); return ; } void NO ( bool f = true ) { YES ( ! f ); return ; } void Yes ( bool f = true ) { f ? Puts ( \"Yes\" ) : Puts ( \"No\" ); return ; } void No ( bool f = true ) { Yes ( ! f ); return ; } void yes ( bool f = true ) { f ? Puts ( \"yes\" ) : Puts ( \"no\" ); return ; } void no ( bool f = true ) { yes ( ! f ); return ; }","title":"YesNo"},{"location":"Other/Convex/SMAWK/","text":"SMAWK \u5b8c\u5168\u5355\u8c03\u77e9\u9635\uff0c\u6c42\u6bcf\u884c\u6700\u5927\u503c\u4f4d\u7f6e\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // max_i (A) template < typename T > vector < int > SMAWK ( int n , int m , auto F ) { vector < int > ans ( n , -1 ); auto Solve = [ & ]( auto self , int n , int m , int * const X , int * const Y ) -> void { if ( n <= 2 || m <= 2 ) { for ( int i = 0 ; i < n ; ++ i ) { int x = X [ i ]; T mx {}; for ( int j = 0 ; j < m ; ++ j ) { int y = Y [ j ]; T w = F ( x , y ); if ( ans [ x ] == -1 || w > mx ) ans [ x ] = y , mx = w ; } } return ; } if ( n < m ) { int k = 0 ; for ( int i = 0 ; i < m ; ++ i ) { int y = Y [ i ]; while ( k && F ( X [ k - 1 ], Y [ k - 1 ]) < F ( X [ k - 1 ], y )) -- k ; if ( k < n ) Y [ k ++ ] = y ; } m = k ; } auto _X = X + n , _Y = Y + m ; int _n = 0 ; for ( int i = 1 ; i < n ; i += 2 ) _X [ _n ++ ] = X [ i ]; for ( int i = 0 ; i < m ; ++ i ) _Y [ i ] = Y [ i ]; self ( self , _n , m , _X , _Y ); int k = 0 ; for ( int i = 0 ; i < n ; i += 2 ) { int lim = i + 1 < n ? ans [ X [ i + 1 ]] : Y [ m - 1 ]; T mx {}; while ( true ) { T w = F ( X [ i ], Y [ k ]); if ( ans [ X [ i ]] == -1 || w > mx ) ans [ X [ i ]] = Y [ k ], mx = w ; if ( Y [ k ] == lim ) break ; ++ k ; } } return ; }; vector < int > X ( n << 1 ), Y ( max ( m , n << 1 )); for ( int i = 0 ; i < n ; ++ i ) X [ i ] = i ; for ( int i = 0 ; i < m ; ++ i ) Y [ i ] = i ; Solve ( Solve , n , m , X . data (), Y . data ()); return ans ; }","title":"SMAWK"},{"location":"Other/Convex/SMAWK/#smawk","text":"\u5b8c\u5168\u5355\u8c03\u77e9\u9635\uff0c\u6c42\u6bcf\u884c\u6700\u5927\u503c\u4f4d\u7f6e\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // max_i (A) template < typename T > vector < int > SMAWK ( int n , int m , auto F ) { vector < int > ans ( n , -1 ); auto Solve = [ & ]( auto self , int n , int m , int * const X , int * const Y ) -> void { if ( n <= 2 || m <= 2 ) { for ( int i = 0 ; i < n ; ++ i ) { int x = X [ i ]; T mx {}; for ( int j = 0 ; j < m ; ++ j ) { int y = Y [ j ]; T w = F ( x , y ); if ( ans [ x ] == -1 || w > mx ) ans [ x ] = y , mx = w ; } } return ; } if ( n < m ) { int k = 0 ; for ( int i = 0 ; i < m ; ++ i ) { int y = Y [ i ]; while ( k && F ( X [ k - 1 ], Y [ k - 1 ]) < F ( X [ k - 1 ], y )) -- k ; if ( k < n ) Y [ k ++ ] = y ; } m = k ; } auto _X = X + n , _Y = Y + m ; int _n = 0 ; for ( int i = 1 ; i < n ; i += 2 ) _X [ _n ++ ] = X [ i ]; for ( int i = 0 ; i < m ; ++ i ) _Y [ i ] = Y [ i ]; self ( self , _n , m , _X , _Y ); int k = 0 ; for ( int i = 0 ; i < n ; i += 2 ) { int lim = i + 1 < n ? ans [ X [ i + 1 ]] : Y [ m - 1 ]; T mx {}; while ( true ) { T w = F ( X [ i ], Y [ k ]); if ( ans [ X [ i ]] == -1 || w > mx ) ans [ X [ i ]] = Y [ k ], mx = w ; if ( Y [ k ] == lim ) break ; ++ k ; } } return ; }; vector < int > X ( n << 1 ), Y ( max ( m , n << 1 )); for ( int i = 0 ; i < n ; ++ i ) X [ i ] = i ; for ( int i = 0 ; i < m ; ++ i ) Y [ i ] = i ; Solve ( Solve , n , m , X . data (), Y . data ()); return ans ; }","title":"SMAWK"}]}